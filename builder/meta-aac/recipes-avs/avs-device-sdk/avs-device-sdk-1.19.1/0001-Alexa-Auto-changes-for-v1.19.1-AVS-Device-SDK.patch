From 9b8850e797dd9be90a4a0a62ce9a15eaa447c67e Mon Sep 17 00:00:00 2001
From: Muni Sakkuru <muni.sakkuru@gmail.com>
Date: Tue, 24 Nov 2020 13:34:39 -0800
Subject: [PATCH 1/1] Alexa Auto changes for v1.19.1 AVS Device SDK

For internal reference: 45cc3665
---
 ACL/src/AVSConnectionManager.cpp              |   4 +-
 ADSL/include/ADSL/DirectiveProcessor.h        |  15 +-
 ADSL/include/ADSL/DirectiveSequencer.h        |   4 +
 ADSL/src/DirectiveProcessor.cpp               |  25 +-
 ADSL/src/DirectiveSequencer.cpp               |   8 +
 ADSL/test/ADSL/MockDirectiveSequencer.h       |   4 +
 AFML/include/AFML/FocusManager.h              |   2 +
 AFML/src/FocusManager.cpp                     |  27 +
 .../AVS/AVSDiscoveryEndpointAttributes.h      |   4 +
 .../AVSCommon/AVS/ActionsToDirectiveMapping.h |  88 +++
 .../AVSCommon/AVS/CapabilitySemantics.h       |  71 ++
 .../AVSCommon/AVS/DialogUXStateAggregator.h   |  45 +-
 .../include/AVSCommon/AVS/EndpointResources.h | 188 +++++
 .../AVS/src/ActionsToDirectiveMapping.cpp     | 101 +++
 AVSCommon/AVS/src/CapabilityResources.cpp     |   5 +-
 AVSCommon/AVS/src/CapabilitySemantics.cpp     |  68 ++
 AVSCommon/AVS/src/DialogUXStateAggregator.cpp | 112 ++-
 AVSCommon/AVS/src/EndpointResources.cpp       | 223 ++++++
 .../AVS/test/CapabilityResourcesTest.cpp      |  16 +-
 .../AVS/test/CapabilitySemanticsTest.cpp      | 223 ++++++
 .../AVS/test/DialogUXStateAggregatorTest.cpp  |  24 +-
 AVSCommon/CMakeLists.txt                      |   5 +
 .../CallStateObserverInterface.h              |  17 +-
 .../DirectiveSequencerInterface.h             |   4 +
 .../Endpoints/EndpointBuilderInterface.h      |  19 +-
 .../SDKInterfaces/FocusManagerInterface.h     |  11 +
 .../Messaging/MessagingObserverInterface.h    | 129 ++++
 .../ModeControllerAttributeBuilderInterface.h |  13 +-
 .../ModeController/ModeControllerAttributes.h |  36 +-
 ...RangeControllerAttributeBuilderInterface.h |  13 +-
 .../RangeControllerAttributes.h               |  34 +-
 ...oggleControllerAttributeBuilderInterface.h |  13 +-
 .../ToggleControllerAttributes.h              |  51 +-
 .../SDKInterfaces/MockDirectiveSequencer.h    |   4 +
 .../SDKInterfaces/MockFocusManager.h          |   1 +
 .../LibcurlUtils/CurlEasyHandleWrapper.h      |  35 +-
 .../AVSCommon/Utils/LibcurlUtils/HttpDelete.h |  83 +++
 .../Utils/LibcurlUtils/HttpDeleteInterface.h  |  56 ++
 .../AVSCommon/Utils/LibcurlUtils/HttpGet.h    |  83 +++
 .../Utils/LibcurlUtils/HttpGetInterface.h     |  56 ++
 .../AVSCommon/Utils/Logger/ThreadMoniker.h    |   9 +-
 .../AVSCommon/Utils/Threading/Executor.h      |  14 +-
 .../include/AVSCommon/Utils/Timing/Timer.h    |   7 +-
 .../LibcurlUtils/CurlEasyHandleWrapper.cpp    |  58 +-
 .../Utils/src/LibcurlUtils/HttpDelete.cpp     | 129 ++++
 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp  | 129 ++++
 .../LibCurlHttpContentFetcher.cpp             |  11 +
 AVSCommon/Utils/src/Logger/ConsoleLogger.cpp  |   2 +-
 AVSCommon/Utils/src/Logger/Logger.cpp         |   2 +-
 AVSCommon/Utils/src/Logger/ThreadMoniker.cpp  |   5 +-
 AVSCommon/Utils/src/Timer.cpp                 |   6 +-
 .../src/Storage/AVSGatewayManagerStorage.cpp  |   6 -
 .../DefaultClient/src/DefaultClient.cpp       |   3 +-
 .../CapabilitiesDelegate.h                    |   3 +
 .../PostConnectCapabilitiesPublisher.h        |   9 +-
 .../src/CapabilitiesDelegate.cpp              |   6 +-
 .../src/PostConnectCapabilitiesPublisher.cpp  |  90 ++-
 .../src/Utils/DiscoveryUtils.cpp              |  32 +-
 .../PostConnectCapabilitiesPublisherTest.cpp  | 108 ++-
 .../AIP/src/AudioInputProcessor.cpp           |   3 +-
 .../AIP/test/AudioInputProcessorTest.cpp      |   1 -
 .../include/Alerts/AlertObserverInterface.h   |  23 +
 .../include/Alerts/AlertsCapabilityAgent.h    |  41 ++
 .../Alerts/include/Alerts/Renderer/Renderer.h |  10 +-
 .../Alerts/src/AlertScheduler.cpp             |   3 +
 .../Alerts/src/AlertsCapabilityAgent.cpp      |  54 ++
 .../Alerts/src/Renderer/Renderer.cpp          |  12 +-
 .../include/AudioPlayer/AudioPlayer.h         |  11 +
 .../AudioPlayer/src/AudioPlayer.cpp           |  22 +-
 .../AudioPlayer/src/CMakeLists.txt            |   7 +-
 .../AudioPlayer/test/AudioPlayerTest.cpp      |  34 +
 .../AudioPlayer/test/CMakeLists.txt           |   5 +-
 CapabilityAgents/CMakeLists.txt               |   1 +
 .../MRM/include/MRM/MRMCapabilityAgent.h      |   4 +-
 .../MRM/src/MRMCapabilityAgent.cpp            |   6 +-
 CapabilityAgents/Messaging/CMakeLists.txt     |   5 +
 .../Messaging/MessagingCapabilityAgent.h      | 513 +++++++++++++
 CapabilityAgents/Messaging/src/CMakeLists.txt |  13 +
 .../src/MessagingCapabilityAgent.cpp          | 697 ++++++++++++++++++
 .../Messaging/test/CMakeLists.txt             |   8 +
 .../ModeControllerAttributeBuilder.h          |   8 +-
 .../src/ModeControllerAttributeBuilder.cpp    |  17 +-
 .../src/ModeControllerCapabilityAgent.cpp     |   8 +-
 .../PlaybackController/PlaybackController.h   |  14 +-
 .../src/PlaybackController.cpp                |  33 +-
 .../RangeControllerAttributeBuilder.h         |   8 +-
 .../src/RangeControllerAttributeBuilder.cpp   |  18 +-
 .../src/RangeControllerCapabilityAgent.cpp    |   9 +-
 .../src/SpeechSynthesizer.cpp                 |  27 +-
 .../System/src/ReportStateHandler.cpp         |   1 -
 .../System/src/SoftwareInfoSendRequest.cpp    |  19 +-
 .../TemplateRuntime/src/TemplateRuntime.cpp   |   6 +-
 .../test/TemplateRuntimeTest.cpp              |   6 +-
 .../ToggleControllerAttributeBuilder.h        |   8 +-
 .../src/ToggleControllerAttributeBuilder.cpp  |  17 +-
 .../src/ToggleControllerCapabilityAgent.cpp   |  15 +-
 .../Implementation/src/SystemClockDelay.cpp   |   2 +-
 CertifiedSender/src/CertifiedSender.cpp       |   5 +-
 .../Endpoints/EndpointAttributeValidation.h   |   8 +
 Endpoints/include/Endpoints/EndpointBuilder.h |   5 +
 Endpoints/src/EndpointAttributeValidation.cpp |   4 +
 Endpoints/src/EndpointBuilder.cpp             |  31 +-
 .../src/MiscDBEqualizerStorage.cpp            |   6 -
 .../test/AudioPlayerIntegrationTest.cpp       |  19 +
 .../include/SampleApp/InteractionManager.h    |   2 +-
 SampleApp/src/InteractionManager.cpp          |   2 +-
 Settings/include/Settings/Setting.h           |   9 +-
 Settings/src/Types/LocaleWakeWordsSetting.cpp |  18 +-
 .../DoNotDisturbCapabilityAgent.h             |  46 +-
 .../src/DoNotDisturbCapabilityAgent.cpp       |   9 +-
 110 files changed, 4136 insertions(+), 266 deletions(-)
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/ActionsToDirectiveMapping.h
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/CapabilitySemantics.h
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
 create mode 100644 AVSCommon/AVS/src/ActionsToDirectiveMapping.cpp
 create mode 100644 AVSCommon/AVS/src/CapabilitySemantics.cpp
 create mode 100644 AVSCommon/AVS/src/EndpointResources.cpp
 create mode 100644 AVSCommon/AVS/test/CapabilitySemanticsTest.cpp
 create mode 100644 AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
 create mode 100644 CapabilityAgents/Messaging/CMakeLists.txt
 create mode 100644 CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
 create mode 100644 CapabilityAgents/Messaging/src/CMakeLists.txt
 create mode 100644 CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
 create mode 100644 CapabilityAgents/Messaging/test/CMakeLists.txt

diff --git a/ACL/src/AVSConnectionManager.cpp b/ACL/src/AVSConnectionManager.cpp
index 8a2c3330..42dfd483 100644
--- a/ACL/src/AVSConnectionManager.cpp
+++ b/ACL/src/AVSConnectionManager.cpp
@@ -138,7 +138,9 @@ void AVSConnectionManager::reconnect() {
 }
 
 void AVSConnectionManager::sendMessage(std::shared_ptr<avsCommon::avs::MessageRequest> request) {
-    m_messageRouter->sendMessage(request);
+    if (m_messageRouter != nullptr) {
+        m_messageRouter->sendMessage(request);
+    }
 }
 
 bool AVSConnectionManager::isConnected() const {
diff --git a/ADSL/include/ADSL/DirectiveProcessor.h b/ADSL/include/ADSL/DirectiveProcessor.h
index 40f1074b..e6f6228b 100644
--- a/ADSL/include/ADSL/DirectiveProcessor.h
+++ b/ADSL/include/ADSL/DirectiveProcessor.h
@@ -81,7 +81,7 @@ public:
      * @param dialogRequestId The new value for the current @c dialogRequestId.
      */
     void setDialogRequestId(const std::string& dialogRequestId);
-
+   
     /**
      * Returns the @c dialogRequestId currently in use for Directive handling. This may be the empty string if
      * Directives have either experienced errors, or have been cancelled.
@@ -90,6 +90,10 @@ public:
      */
     std::string getDialogRequestId();
 
+    void setIsDialogRequestOnline(bool isOnline);
+
+    bool isDialogRequestOnline();
+
     /**
      * Queue an @c AVSDirective for handling by whatever @c DirectiveHandler was registered to handle it.
      *
@@ -192,6 +196,12 @@ private:
      */
     void processingLoop();
 
+    void setIsDialogRequestOnlineLocked(bool isOnline);
+
+    bool isDialogRequestOnlineLocked();
+
+    std::string getDialogRequestIdLocked();
+
     /**
      * Process (cancel) all the items in @c m_cancelingQueue.
      * @note This method must only be called by threads that have acquired @c m_mutex.
@@ -293,6 +303,9 @@ private:
     /// Whether or not the @c DirectiveProcessor is enabled.
     bool m_isEnabled;
 
+    /// Whether the current dialog request is from AVS (online) or AHE (offline)
+    bool m_isDialogRequestOnline;
+
     /// The current @c dialogRequestId
     std::string m_dialogRequestId;
 
diff --git a/ADSL/include/ADSL/DirectiveSequencer.h b/ADSL/include/ADSL/DirectiveSequencer.h
index 4ee5051b..643809ae 100644
--- a/ADSL/include/ADSL/DirectiveSequencer.h
+++ b/ADSL/include/ADSL/DirectiveSequencer.h
@@ -57,6 +57,10 @@ public:
 
     std::string getDialogRequestId() override;
 
+    void setIsDialogRequestOnline(bool isOnline) override;
+
+    bool isDialogRequestOnline() override;
+
     bool onDirective(std::shared_ptr<avsCommon::avs::AVSDirective> directive) override;
 
     void disable() override;
diff --git a/ADSL/src/DirectiveProcessor.cpp b/ADSL/src/DirectiveProcessor.cpp
index 2ecbf4a9..fcc8c3b6 100644
--- a/ADSL/src/DirectiveProcessor.cpp
+++ b/ADSL/src/DirectiveProcessor.cpp
@@ -47,7 +47,8 @@ std::unordered_map<DirectiveProcessor::ProcessorHandle, DirectiveProcessor*> Dir
 DirectiveProcessor::DirectiveProcessor(DirectiveRouter* directiveRouter) :
         m_directiveRouter{directiveRouter},
         m_isShuttingDown{false},
-        m_isEnabled{true} {
+        m_isEnabled{true},
+        m_isDialogRequestOnline{true} {
     std::lock_guard<std::mutex> lock(m_handleMapMutex);
     m_handle = ++m_nextProcessorHandle;
     m_handleMap[m_handle] = this;
@@ -68,6 +69,16 @@ std::string DirectiveProcessor::getDialogRequestId() {
     return m_dialogRequestId;
 }
 
+void DirectiveProcessor::setIsDialogRequestOnline(bool isOnline) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    setIsDialogRequestOnlineLocked(isOnline);
+}
+
+bool DirectiveProcessor::isDialogRequestOnline() {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    return isDialogRequestOnlineLocked();
+}
+
 bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
@@ -122,6 +133,18 @@ bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     return true;
 }
 
+std::string DirectiveProcessor::getDialogRequestIdLocked() {
+    return m_dialogRequestId;
+}
+
+void DirectiveProcessor::setIsDialogRequestOnlineLocked(bool isOnline) {
+    m_isDialogRequestOnline = isOnline;
+}
+
+bool DirectiveProcessor::isDialogRequestOnlineLocked() {
+    return m_isDialogRequestOnline;
+}
+
 void DirectiveProcessor::shutdown() {
     {
         std::lock_guard<std::mutex> lock(m_handleMapMutex);
diff --git a/ADSL/src/DirectiveSequencer.cpp b/ADSL/src/DirectiveSequencer.cpp
index a9045480..763bd30a 100644
--- a/ADSL/src/DirectiveSequencer.cpp
+++ b/ADSL/src/DirectiveSequencer.cpp
@@ -67,6 +67,14 @@ std::string DirectiveSequencer::getDialogRequestId() {
     return m_directiveProcessor->getDialogRequestId();
 }
 
+bool DirectiveSequencer::isDialogRequestOnline() {
+    return m_directiveProcessor->isDialogRequestOnline();
+}
+
+void DirectiveSequencer::setIsDialogRequestOnline(bool isOnline) {
+    m_directiveProcessor->setIsDialogRequestOnline(isOnline);
+}
+
 bool DirectiveSequencer::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
diff --git a/ADSL/test/ADSL/MockDirectiveSequencer.h b/ADSL/test/ADSL/MockDirectiveSequencer.h
index 7773c70d..f0f3f01d 100644
--- a/ADSL/test/ADSL/MockDirectiveSequencer.h
+++ b/ADSL/test/ADSL/MockDirectiveSequencer.h
@@ -51,6 +51,10 @@ public:
         return m_dialogRequestId;
     };
 
+    MOCK_METHOD0(isDialogRequestOnline, bool());
+    
+    MOCK_METHOD1(setIsDialogRequestOnline, void(bool));
+
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
 
     MOCK_METHOD0(disable, void());
diff --git a/AFML/include/AFML/FocusManager.h b/AFML/include/AFML/FocusManager.h
index cbddf598..c11b195c 100644
--- a/AFML/include/AFML/FocusManager.h
+++ b/AFML/include/AFML/FocusManager.h
@@ -133,6 +133,8 @@ public:
         const std::string& channelName,
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver) override;
 
+    bool releaseChannel(const std::string& channelName) override;
+
     void stopForegroundActivity() override;
 
     void stopAllActivities() override;
diff --git a/AFML/src/FocusManager.cpp b/AFML/src/FocusManager.cpp
index 87ad0398..85a126db 100644
--- a/AFML/src/FocusManager.cpp
+++ b/AFML/src/FocusManager.cpp
@@ -122,6 +122,33 @@ std::future<bool> FocusManager::releaseChannel(
     return returnValue;
 }
 
+bool FocusManager::releaseChannel(const std::string& channelName) {
+    ACSDK_DEBUG1(LX("releaseChannel").d("channelName", channelName));
+
+    std::shared_ptr<Channel> channelToRelease = getChannel(channelName);
+    if (!channelToRelease) {
+        ACSDK_ERROR(LX("releaseChannelFailed").d("reason", "channelNotFound").d("channelName", channelName));
+        return false;
+    }
+
+    auto task = [this, channelToRelease]() {
+        // Lock here to update internal state which stopForegroundActivity may concurrently access.
+        std::unique_lock<std::mutex> lock(m_mutex);
+        bool wasForegrounded = isChannelForegroundedLocked(channelToRelease);
+        m_activeChannels.erase(channelToRelease);
+        lock.unlock();
+
+        setChannelFocus(channelToRelease, FocusState::NONE, MixingBehavior::MUST_STOP);
+        if (wasForegrounded) {
+            foregroundHighestPriorityActiveChannel();
+        }
+        notifyActivityTracker();
+    };
+
+    m_executor.submit(task);
+    return true;
+}
+
 void FocusManager::stopForegroundActivity() {
     // We lock these variables so that we can correctly capture the currently foregrounded channel and activity.
     std::unique_lock<std::mutex> lock(m_mutex);
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
index a15c9454..d0c5c681 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <vector>
 
+#include <AVSCommon/AVS/EndpointResources.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h>
 #include <AVSCommon/Utils/Optional.h>
 
@@ -123,6 +124,9 @@ struct AVSDiscoveryEndpointAttributes {
     /// A non-empty string identifying the endpoint manufacturer name.
     std::string manufacturerName;
 
+    /// An EndpointResources object containing friendly names, manufacturer name and description.
+    EndpointResources endpointResources;
+
     /// The display categories the device belongs to. This field should contain at least one category. See categories
     /// in this document: https://developer.amazon.com/docs/alexa/device-apis/alexa-discovery.html#display-categories
     /// @note: This value should only include ALEXA_VOICE_ENABLED for the default endpoint.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/ActionsToDirectiveMapping.h b/AVSCommon/AVS/include/AVSCommon/AVS/ActionsToDirectiveMapping.h
new file mode 100644
index 00000000..3d915c63
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/ActionsToDirectiveMapping.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ACTIONSTODIRECTIVEMAPPING_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ACTIONSTODIRECTIVEMAPPING_H_
+
+#include <string>
+#include <vector>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+/**
+ * This class represents an "ActionsToDirective" "actionMapping" in a semantic annotation for a capability
+ * @see https://developer.amazon.com/en-US/docs/alexa/device-apis/alexa-discovery.html#semantics-object
+ */
+class ActionsToDirectiveMapping {
+public:
+    /**
+     * The constructor.
+     */
+    ActionsToDirectiveMapping();
+
+    /**
+     * Adds the specified action to the "actions" array of this action mapping object.
+     *
+     * @param action The action to add to the "actions" array
+     * @return @c true if the action was successfully added, else @c false.
+     */
+    bool addAction(const std::string& action);
+
+    /**
+     * Sets the directive used by this action mapping
+     *
+     * @param name The name of the directive. Must be a valid directive of the capability interface to which the
+     *        semantics object belongs.
+     * @param payload The desired payload of the directive used in this action mapping.
+     * @return @c true if the directive was successfully set, else @c false.
+     */
+    bool setDirective(const std::string& name, const std::string& payload = "{}");
+
+    /**
+     * Checks whether this @c ActionsToDirectiveMapping is valid.
+     *
+     * @return @c true if valid, else @c false.
+     */
+    bool isValid() const;
+
+    /**
+     * Converts this ActionsToDirectiveMapping to a JSON string.
+     *
+     * @note This follows the AVS discovery message format.
+     *
+     * @return A JSON string of this @c ActionsToDirectiveMapping.
+     */
+    std::string toJson() const;
+
+private:
+    /// Indicates an error in construction;
+    bool m_isValid;
+
+    /// List of actions used in this mapping
+    std::vector<std::string> m_actions;
+
+    /// The name of the directive used in this mapping
+    std::string m_directiveName;
+
+    /// The directive payload used in this mapping
+    std::string m_directivePayload;
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ACTIONSTODIRECTIVEMAPPING_H_
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/CapabilitySemantics.h b/AVSCommon/AVS/include/AVSCommon/AVS/CapabilitySemantics.h
new file mode 100644
index 00000000..4a39a401
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/CapabilitySemantics.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_CAPABILITYSEMANTICS_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_CAPABILITYSEMANTICS_H_
+
+#include <vector>
+#include <string>
+
+#include <AVSCommon/AVS/ActionsToDirectiveMapping.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+/**
+ * This class represents the 'semantics' object of a capability definition.
+ * @see https://developer.amazon.com/en-US/docs/alexa/device-apis/alexa-discovery.html#semantics-object
+ */
+class CapabilitySemantics {
+public:
+    /**
+     * The default constructor.
+     */
+    CapabilitySemantics() = default;
+
+    /**
+     * Adds an @c ActionsToDirectiveMapping to this semantics definition.
+     *
+     * @param mapping The action mapping represented as an @c ActionsToDirectiveMapping.
+     * @return @c true if adding the mapping was successful, else @c false.
+     */
+    bool addActionsToDirectiveMapping(const ActionsToDirectiveMapping& mapping);
+
+    /**
+     * Checks if the @c CapabilitySemantics is valid.
+     *
+     * @return @c true if valid, else @c false.
+     */
+    bool isValid() const;
+
+    /**
+     * Converts this semantics object to a JSON string.
+     *
+     * @note This follows the AVS discovery message format.
+     *
+     * @return A JSON string representation of this @c CapabilitySemantics.
+     */
+    std::string toJson() const;
+
+private:
+    /// Vector holding the @c ActionsToDirectiveMapping action mappings.
+    std::vector<ActionsToDirectiveMapping> m_actionMappings;
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_CAPABILITYSEMANTICS_H_
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
index cb7ef738..c99726d1 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/DialogUXStateAggregator.h
@@ -19,6 +19,7 @@
 #include <atomic>
 #include <chrono>
 #include <unordered_set>
+#include <vector>
 
 #include "AVSCommon/SDKInterfaces/AudioInputProcessorObserverInterface.h"
 #include <AVSCommon/SDKInterfaces/ConnectionStatusObserverInterface.h>
@@ -41,10 +42,27 @@ namespace avs {
 class DialogUXStateAggregator
         : public sdkInterfaces::AudioInputProcessorObserverInterface
         , public sdkInterfaces::SpeechSynthesizerObserverInterface
-        , public sdkInterfaces::MessageObserverInterface
         , public sdkInterfaces::ConnectionStatusObserverInterface
         , public sdkInterfaces::InteractionModelRequestProcessingObserverInterface {
 public:
+    /**
+     * This timeout will be used to avoid going to the IDLE state immediately after receiving a message from AVS so
+     * that other UX states (such as speech starting) may be processed and propagated before going to IDLE.
+     */
+    static constexpr std::chrono::milliseconds SHORT_TIMEOUT_FOR_THINKING_TO_IDLE = std::chrono::milliseconds{200};
+
+    /**
+     * This timeout will be used to time out from the THINKING state in case no messages arrive from AVS so that the
+     * client may move back to an IDLE state.
+     */
+    static constexpr std::chrono::seconds LONG_TIMEOUT_FOR_THINKING_TO_IDLE = std::chrono::seconds{8};
+
+    /**
+     * This timeout will be used to time out from the LISTENING state in case the Request Processing Started (RPS)
+     * directive is not received from AVS so that the client may move back to an IDLE state.
+     */
+    static constexpr std::chrono::seconds LONG_TIMEOUT_FOR_LISTENING_TO_IDLE = std::chrono::seconds{8};
+
     /**
      * Constructor.
      *
@@ -55,11 +73,13 @@ public:
      * arrive from AVS.
      * @param timeoutForListeningToIdle This timeout will be used to time out from the LISTENING state in case the
      * Request Processing Started (RPS) directive is not received from AVS.
+     * @param shortTimeoutForThinkingToIdle This timeout will be used to avoid going to the IDLE state immediately
      */
     DialogUXStateAggregator(
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr,
-        std::chrono::milliseconds timeoutForThinkingToIdle = std::chrono::seconds{8},
-        std::chrono::milliseconds timeoutForListeningToIdle = std::chrono::seconds{8});
+        std::chrono::milliseconds timeoutForThinkingToIdle = LONG_TIMEOUT_FOR_THINKING_TO_IDLE,
+        std::chrono::milliseconds timeoutForListeningToIdle = LONG_TIMEOUT_FOR_LISTENING_TO_IDLE,
+        std::chrono::milliseconds shortTimeoutForThinkingToIdle = SHORT_TIMEOUT_FOR_THINKING_TO_IDLE);
 
     /**
      * Adds an observer to be notified of UX state changes.
@@ -91,8 +111,6 @@ public:
         const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId,
         const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState>& mediaPlayerState) override;
 
-    void receive(const std::string& contextId, const std::string& message) override;
-
     /// @name InteractionModelRequestProcessingObserverInterface Functions
     /// @{
     void onRequestProcessingStarted() override;
@@ -109,14 +127,21 @@ private:
      * Sets the internal state to the new state.
      *
      * @param newState The new Alexa UX state.
+     * @return Whether the state transition was successful.
      */
-    void setState(sdkInterfaces::DialogUXStateObserverInterface::DialogUXState newState);
+    bool executeSetState(sdkInterfaces::DialogUXStateObserverInterface::DialogUXState newState);
 
     /**
      * Sets the internal state to @c IDLE if both @c SpeechSynthesizer and @c AudioInputProcessor are in idle state.
      */
     void tryEnterIdleState();
 
+    /**
+     * An event has occurred which may transition @c DialogUXStateAggregator out of THINKING mode. This function
+     * evaluates if the transition is valid and performs the necessary logic to prepare for the transition.
+     */
+    void tryExitThinkingState();
+
     /**
      * Transitions the internal state from THINKING to IDLE.
      */
@@ -162,6 +187,12 @@ private:
     /// The timeout to be used for transitioning away from the THINKING state in case no messages are received.
     const std::chrono::milliseconds m_timeoutForThinkingToIdle;
 
+    /**
+     * This timeout will be used to avoid going to the IDLE state immediately after receiving a message from AVS so
+     * that other UX states (such as speech starting) may be processed and propagated.
+     */
+    const std::chrono::milliseconds m_shortTimeoutForThinkingToIdle;
+
     /// A timer to transition out of the THINKING state.
     avsCommon::utils::timing::Timer m_thinkingTimeoutTimer;
 
@@ -170,7 +201,7 @@ private:
 
     /// The timeout to be used for transitioning away form the LISTENING state in case RPS (Request Processing Started)
     /// directive is not received.
-    const std::chrono::microseconds m_timeoutForListeningToIdle;
+    const std::chrono::milliseconds m_timeoutForListeningToIdle;
 
     /// A timer to transition out of the LISTENING state to IDLE state in case RPS (Request Processing Started)
     /// directive is not received.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
new file mode 100644
index 00000000..1bb0b5bf
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+
+#include <string>
+#include <vector>
+
+#include <AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h>
+#include <AVSCommon/Utils/Optional.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+class EndpointResources {
+public:
+    /**
+     * The constructor.
+     */
+    EndpointResources();
+
+    /**
+     * Function to add friendly name using asset id.
+     * 
+     * @param assetId The asset id of the friendly name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add friendly name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the friendly names
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the friendly name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the friendly name. 
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithText(
+            const std::string& text,
+            const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale);
+
+    /**
+     * Function to add manufacturer name using asset id.
+     *
+     * @param assetId The asset id of the manufacturer name using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add manufacturer name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the manufacturer name
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the manufacturer name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the manufacturer name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithText(
+            const std::string& text,
+            const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale);
+
+    /**
+     * Function to add description using asset id.
+     *
+     * @param assetId The asset id of the description using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add description using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the description
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the description. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the description.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithText(
+            const std::string& text,
+            const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale);
+
+    /**
+     * Function to check if the @c EndpointResources is valid.
+     *
+     * @return Return @c true if valid, otherwise @c false.
+     */
+     bool isValid() const;
+
+    /**
+     * Builds a new EndpointResources with the configured properties.
+     *
+     * Build will fail if any attribute is invalid or if a mandatory attribute is missing.
+     *
+     * @return A json string representing the EndpointResources; otherwise, an empty string.
+     */
+     std::string build() const;
+
+private:
+    /**
+     * Struct defining a Label, used to describe a resource.
+     * @see https://developer.amazon.com/docs/device-apis/resources-and-assets.html#capability-resources
+     */
+    struct Label {
+        /// The enum representing the Label type.
+        enum class LabelType {
+            /// Asset type.
+            ASSET,
+
+            /// Text type.
+            TEXT
+        };
+
+        /// The type of the Label. 
+        LabelType type;
+
+        /// The value to contain the text or the asset id of the friendly name, manufacturer name or description.
+        std::string value;
+
+        /// The locale of the text, and empty object for asset.
+        avsCommon::utils::Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale> locale;
+
+        /**
+         *  @name Comparison operator.
+         *
+         *  Compare the current Label against a second object.
+         *  Defined for std::find.
+         *
+         *  @param rhs The object to compare against this.
+         *  @return @c true if the comparison holds; @c false otherwise.
+         */
+        /// @{
+        bool operator==(const Label& rhs) const;
+        /// @}
+
+        /**
+         * Helper function to convert a Label to a json string.
+         *
+         * @return A json string of Label.
+         */
+        std::string toJson() const;
+    };
+
+    /// Flag to indicate if there was any error noted.
+    bool m_isValid = false;
+
+    /// Vector holding @c Label for the friendly names.
+    std::vector<Label> m_friendlyNames;
+
+    /// @c Label that holds the manufacturer name.
+    Label m_manufacturerName;
+
+    /// @c Label that holds the description.
+    Label m_description;
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif //ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
diff --git a/AVSCommon/AVS/src/ActionsToDirectiveMapping.cpp b/AVSCommon/AVS/src/ActionsToDirectiveMapping.cpp
new file mode 100644
index 00000000..2982765a
--- /dev/null
+++ b/AVSCommon/AVS/src/ActionsToDirectiveMapping.cpp
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/AVS/ActionsToDirectiveMapping.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include <algorithm>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("ActionsToDirectiveMapping");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) utils::logger::LogEntry(TAG, event)
+
+ActionsToDirectiveMapping::ActionsToDirectiveMapping() : m_isValid{true} {
+}
+
+bool ActionsToDirectiveMapping::addAction(const std::string& action) {
+    if (action == "") {
+        ACSDK_ERROR(LX("addActionFailed").d("reason", "emptyAction"));
+        m_isValid = false;
+        return false;
+    }
+    if (std::find(m_actions.begin(), m_actions.end(), action) != m_actions.end()) {
+        ACSDK_ERROR(LX("addActionFailed").d("reason", "duplicateAction").d("action", action));
+        m_isValid = false;
+        return false;
+    }
+    m_actions.push_back(action);
+    return true;
+}
+
+bool ActionsToDirectiveMapping::setDirective(const std::string& directive, const std::string& payload) {
+    if (directive == "") {
+        ACSDK_ERROR(LX("setDirectiveFailed").d("reason", "emptyDirectiveName"));
+        m_isValid = false;
+        return false;
+    }
+    if (payload == "") {
+        ACSDK_ERROR(LX("setDirectiveFailed").d("reason", "emptyPayload"));
+        m_isValid = false;
+        return false;
+    }
+    if (m_directiveName != "") {
+        ACSDK_ERROR(LX("setDirectiveFailed").d("directive", directive).d("reason", "directiveAlreadySet"));
+        m_isValid = false;
+        return false;
+    }
+    m_directiveName = directive;
+    m_directivePayload = payload;
+    return true;
+}
+
+bool ActionsToDirectiveMapping::isValid() const {
+    return m_isValid && !m_actions.empty() && (m_directiveName != "");
+}
+
+std::string ActionsToDirectiveMapping::toJson() const {
+    if (!isValid()) {
+        ACSDK_ERROR(LX("toJsonFailed").d("reason", "invalidActionsToDirectiveMapping"));
+        return "{}";
+    }
+
+    utils::json::JsonGenerator jsonGenerator;
+    jsonGenerator.addMember("@type", "ActionsToDirective");
+    jsonGenerator.addStringArray("actions", m_actions);
+    jsonGenerator.startObject("directive");
+    jsonGenerator.addMember("name", m_directiveName);
+    bool parseSuccess = jsonGenerator.addRawJsonMember("payload", m_directivePayload, true);
+    if (!parseSuccess) {
+        ACSDK_ERROR(LX("toJsonFailed").d("reason", "payloadNotValidJson"));
+        return "{}";
+    }
+    jsonGenerator.finishObject();  // directive
+    return jsonGenerator.toString();
+}
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/src/CapabilityResources.cpp b/AVSCommon/AVS/src/CapabilityResources.cpp
index 8905b8ed..7a6066c2 100644
--- a/AVSCommon/AVS/src/CapabilityResources.cpp
+++ b/AVSCommon/AVS/src/CapabilityResources.cpp
@@ -84,12 +84,11 @@ bool CapabilityResources::addFriendlyNameWithText(
             CapabilityResources::FriendlyName(
                 {text, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)})) !=
         m_items.end()) {
-        ACSDK_ERROR(LX("addFriendlyNameWithTextFailed")
+        ACSDK_WARN(LX("addFriendlyNameWithTextFailed")
                         .d("reason", "duplicateText")
                         .sensitive("text", text)
                         .sensitive("locale", locale));
-        m_isValid = false;
-        return false;
+        return true;
     }
 
     m_items.push_back({text, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)});
diff --git a/AVSCommon/AVS/src/CapabilitySemantics.cpp b/AVSCommon/AVS/src/CapabilitySemantics.cpp
new file mode 100644
index 00000000..d5f17740
--- /dev/null
+++ b/AVSCommon/AVS/src/CapabilitySemantics.cpp
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <algorithm>
+
+#include <AVSCommon/AVS/CapabilitySemantics.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("CapabilitySemantics");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) utils::logger::LogEntry(TAG, event)
+
+bool CapabilitySemantics::addActionsToDirectiveMapping(const ActionsToDirectiveMapping& mapping) {
+    if (mapping.isValid()) {
+        m_actionMappings.push_back(mapping);
+        return true;
+    } else {
+        ACSDK_ERROR(LX("addActionsToDirectiveMappingFailed").d("reason", "invalidMapping"));
+        return false;
+    }
+}
+
+bool CapabilitySemantics::isValid() const {
+    // Since we don't yet have 'stateMappings', we require at least one 'actionMapping'
+    return !m_actionMappings.empty();
+}
+
+std::string CapabilitySemantics::toJson() const {
+    if (!isValid()) {
+        ACSDK_ERROR(LX("toJsonFailed").d("reason", "invalidCapabilitySemantics"));
+        return "{}";
+    }
+
+    utils::json::JsonGenerator jsonGenerator;
+    std::vector<std::string> actionMappingJsonList;
+    for (const auto& mapping : m_actionMappings) {
+        actionMappingJsonList.push_back(mapping.toJson());
+    }
+    jsonGenerator.addMembersArray("actionMappings", actionMappingJsonList);
+    return jsonGenerator.toString();
+}
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
index 13431e65..2d9ed9e6 100644
--- a/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
+++ b/AVSCommon/AVS/src/DialogUXStateAggregator.cpp
@@ -34,11 +34,6 @@ static const std::string TAG("DialogUXStateAggregator");
  */
 #define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
 
-/**
- * A short timeout that is used to avoid going to the IDLE state immediately while waiting for other state changes.
- */
-static const std::chrono::milliseconds SHORT_TIMEOUT{200};
-
 /// Custom Metrics prefix used by DialogUXStateAggregator.
 static const std::string CUSTOM_METRIC_PREFIX = "CUSTOM-";
 
@@ -48,6 +43,10 @@ static const std::string LISTENING_TIMEOUT_EXPIRES = "LISTENING_TIMEOUT_EXPIRES"
 /// error metric for Thinking timeout expires
 static const std::string THINKING_TIMEOUT_EXPIRES = "THINKING_TIMEOUT_EXPIRES";
 
+constexpr std::chrono::milliseconds DialogUXStateAggregator::SHORT_TIMEOUT_FOR_THINKING_TO_IDLE;
+constexpr std::chrono::seconds DialogUXStateAggregator::LONG_TIMEOUT_FOR_THINKING_TO_IDLE;
+constexpr std::chrono::seconds DialogUXStateAggregator::LONG_TIMEOUT_FOR_LISTENING_TO_IDLE;
+
 /**
  * Submits a metric of given event name
  * @param metricRecorder The @c MetricRecorderInterface which records Metric events
@@ -73,13 +72,19 @@ static void submitMetric(const std::shared_ptr<MetricRecorderInterface>& metricR
 DialogUXStateAggregator::DialogUXStateAggregator(
     std::shared_ptr<MetricRecorderInterface> metricRecorder,
     std::chrono::milliseconds timeoutForThinkingToIdle,
-    std::chrono::milliseconds timeoutForListeningToIdle) :
+    std::chrono::milliseconds timeoutForListeningToIdle,
+    std::chrono::milliseconds shortTimeoutForThinkingToIdle) :
         m_metricRecorder{metricRecorder},
         m_currentState{DialogUXStateObserverInterface::DialogUXState::IDLE},
         m_timeoutForThinkingToIdle{timeoutForThinkingToIdle},
+        m_shortTimeoutForThinkingToIdle{shortTimeoutForThinkingToIdle},
         m_timeoutForListeningToIdle{timeoutForListeningToIdle},
         m_speechSynthesizerState{SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED},
         m_audioInputProcessorState{AudioInputProcessorObserverInterface::State::IDLE} {
+    ACSDK_DEBUG8(LX("timeout values in milliseconds")
+                     .d("m_timeoutForThinkingToIdle", m_timeoutForThinkingToIdle.count())
+                     .d("m_shortTimeoutForThinkingToIdle", m_shortTimeoutForThinkingToIdle.count())
+                     .d("m_timeoutForListeningToIdle", m_timeoutForListeningToIdle.count()));
 }
 
 void DialogUXStateAggregator::addObserver(std::shared_ptr<DialogUXStateObserverInterface> observer) {
@@ -102,29 +107,32 @@ void DialogUXStateAggregator::removeObserver(std::shared_ptr<DialogUXStateObserv
 }
 
 void DialogUXStateAggregator::onStateChanged(AudioInputProcessorObserverInterface::State state) {
+    ACSDK_DEBUG0(LX(__func__).d("AudioInputProcessorState", state));
     m_audioInputProcessorState = state;
-
     m_executor.submit([this, state]() {
+        ACSDK_DEBUG0(LX("onStateChangedLambda").d("AudioInputProcessorState", state));
         switch (state) {
             case AudioInputProcessorObserverInterface::State::IDLE:
                 tryEnterIdleState();
                 return;
             case AudioInputProcessorObserverInterface::State::RECOGNIZING:
                 onActivityStarted();
-                setState(DialogUXStateObserverInterface::DialogUXState::LISTENING);
+                executeSetState(DialogUXStateObserverInterface::DialogUXState::LISTENING);
                 return;
             case AudioInputProcessorObserverInterface::State::EXPECTING_SPEECH:
                 onActivityStarted();
-                setState(DialogUXStateObserverInterface::DialogUXState::EXPECTING);
+                executeSetState(DialogUXStateObserverInterface::DialogUXState::EXPECTING);
                 return;
             case AudioInputProcessorObserverInterface::State::BUSY:
-                setState(DialogUXStateObserverInterface::DialogUXState::LISTENING);
-                if (!m_listeningTimeoutTimer
-                         .start(
-                             m_timeoutForListeningToIdle,
-                             std::bind(&DialogUXStateAggregator::transitionFromListeningTimedOut, this))
-                         .valid()) {
-                    ACSDK_ERROR(LX("failedToStartTimerFromListeningToIdle"));
+                if (executeSetState(DialogUXStateObserverInterface::DialogUXState::LISTENING) ||
+                    DialogUXStateObserverInterface::DialogUXState::LISTENING == m_currentState) {
+                    if (!m_listeningTimeoutTimer
+                             .start(
+                                 m_timeoutForListeningToIdle,
+                                 std::bind(&DialogUXStateAggregator::transitionFromListeningTimedOut, this))
+                             .valid()) {
+                        ACSDK_ERROR(LX("failedToStartTimerFromListeningToIdle"));
+                    }
                 }
                 return;
         }
@@ -136,13 +144,14 @@ void DialogUXStateAggregator::onStateChanged(
     SpeechSynthesizerObserverInterface::SpeechSynthesizerState state,
     const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId mediaSourceId,
     const avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::MediaPlayerState>& mediaPlayerState) {
+    ACSDK_DEBUG0(LX(__func__).d("SpeechSynthesizerState", state));
     m_speechSynthesizerState = state;
-
     m_executor.submit([this, state]() {
+        ACSDK_DEBUG0(LX("onStateChangedLambda").d("SpeechSynthesizerState", state));
         switch (state) {
             case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING:
                 onActivityStarted();
-                setState(DialogUXStateObserverInterface::DialogUXState::SPEAKING);
+                executeSetState(DialogUXStateObserverInterface::DialogUXState::SPEAKING);
                 return;
             case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED:
             case SpeechSynthesizerObserverInterface::SpeechSynthesizerState::INTERRUPTED:
@@ -158,10 +167,14 @@ void DialogUXStateAggregator::onStateChanged(
     });
 }
 
-void DialogUXStateAggregator::receive(const std::string& contextId, const std::string& message) {
+void DialogUXStateAggregator::tryExitThinkingState() {
+    ACSDK_DEBUG0(LX(__func__));
     m_executor.submit([this]() {
+        ACSDK_DEBUG0(LX("tryExitThinkingStateLambda"));
         if (DialogUXStateObserverInterface::DialogUXState::THINKING == m_currentState &&
             SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS != m_speechSynthesizerState) {
+            ACSDK_DEBUG5(
+                LX("Kicking off short timer").d("shortTimeout in ms", m_shortTimeoutForThinkingToIdle.count()));
             /*
              * Stop the long timer and start a short timer so that either the state will change (i.e. Speech begins)
              * or we automatically go to idle after the short timeout (i.e. the directive received isn't related to
@@ -170,7 +183,8 @@ void DialogUXStateAggregator::receive(const std::string& contextId, const std::s
              */
             m_thinkingTimeoutTimer.stop();
             m_thinkingTimeoutTimer.start(
-                SHORT_TIMEOUT, std::bind(&DialogUXStateAggregator::transitionFromThinkingTimedOut, this));
+                m_shortTimeoutForThinkingToIdle,
+                std::bind(&DialogUXStateAggregator::transitionFromThinkingTimedOut, this));
         }
     });
 }
@@ -180,26 +194,24 @@ void DialogUXStateAggregator::onConnectionStatusChanged(
     const ConnectionStatusObserverInterface::ChangedReason reason) {
     m_executor.submit([this, status]() {
         if (status != avsCommon::sdkInterfaces::ConnectionStatusObserverInterface::Status::CONNECTED) {
-            setState(DialogUXStateObserverInterface::DialogUXState::IDLE);
+            executeSetState(DialogUXStateObserverInterface::DialogUXState::IDLE);
         }
     });
 }
 
 void DialogUXStateAggregator::onRequestProcessingStarted() {
-    ACSDK_DEBUG(LX("onRequestProcessingStarted"));
+    ACSDK_DEBUG0(LX("onRequestProcessingStarted"));
     m_executor.submit([this]() {
+        ACSDK_DEBUG0(LX("onRequestProcessingStartedLambda").d("currentState", m_currentState));
         // Stop the listening timer
         m_listeningTimeoutTimer.stop();
-
-        ACSDK_DEBUG0(LX("onRequestProcessingStartedLambda").d("currentState", m_currentState));
-
         switch (m_currentState) {
             // IDLE is included for the theoretical edgecase that RPS is received after the listening timeout occurs.
             case DialogUXStateObserverInterface::DialogUXState::IDLE:
                 ACSDK_WARN(LX("onRequestProcessingStartedLambda").d("reason", "transitioningFromIdle"));
             /* FALL-THROUGH */
             case DialogUXStateObserverInterface::DialogUXState::LISTENING:
-                setState(DialogUXStateObserverInterface::DialogUXState::THINKING);
+                executeSetState(DialogUXStateObserverInterface::DialogUXState::THINKING);
 
                 if (!m_thinkingTimeoutTimer
                          .start(
@@ -218,13 +230,8 @@ void DialogUXStateAggregator::onRequestProcessingStarted() {
 }
 
 void DialogUXStateAggregator::onRequestProcessingCompleted() {
-    // No-op
-    /*
-     * No particular processing is needed for this directive. The RequestProcessCompleted directive exists in the
-     * Interaction Model 1.1 to let AVS activate a logic that stops the thinking mode without any other semantic. But
-     * the specification is such that any directive will interrupt the thinking mode. So here we are simply confirming
-     * that this directive is supported.
-     */
+    ACSDK_DEBUG(LX("onRequestProcessingCompleted"));
+    tryExitThinkingState();
 }
 
 void DialogUXStateAggregator::notifyObserversOfState() {
@@ -239,7 +246,7 @@ void DialogUXStateAggregator::transitionFromThinkingTimedOut() {
     m_executor.submit([this]() {
         if (DialogUXStateObserverInterface::DialogUXState::THINKING == m_currentState) {
             ACSDK_DEBUG(LX("transitionFromThinkingTimedOut"));
-            setState(DialogUXStateObserverInterface::DialogUXState::IDLE);
+            executeSetState(DialogUXStateObserverInterface::DialogUXState::IDLE);
 
             submitMetric(m_metricRecorder, THINKING_TIMEOUT_EXPIRES);
         }
@@ -250,7 +257,7 @@ void DialogUXStateAggregator::transitionFromListeningTimedOut() {
     m_executor.submit([this]() {
         if (DialogUXStateObserverInterface::DialogUXState::LISTENING == m_currentState) {
             ACSDK_DEBUG(LX("transitionFromListeningTimedOut"));
-            setState(DialogUXStateObserverInterface::DialogUXState::IDLE);
+            executeSetState(DialogUXStateObserverInterface::DialogUXState::IDLE);
 
             submitMetric(m_metricRecorder, LISTENING_TIMEOUT_EXPIRES);
         }
@@ -263,21 +270,45 @@ void DialogUXStateAggregator::tryEnterIdleStateOnTimer() {
             m_audioInputProcessorState == AudioInputProcessorObserverInterface::State::IDLE &&
             (m_speechSynthesizerState == SpeechSynthesizerObserverInterface::SpeechSynthesizerState::FINISHED ||
              m_speechSynthesizerState == SpeechSynthesizerObserverInterface::SpeechSynthesizerState::INTERRUPTED)) {
-            setState(sdkInterfaces::DialogUXStateObserverInterface::DialogUXState::IDLE);
+            executeSetState(sdkInterfaces::DialogUXStateObserverInterface::DialogUXState::IDLE);
         }
     });
 }
 
-void DialogUXStateAggregator::setState(sdkInterfaces::DialogUXStateObserverInterface::DialogUXState newState) {
+bool DialogUXStateAggregator::executeSetState(sdkInterfaces::DialogUXStateObserverInterface::DialogUXState newState) {
+    bool validTransition = true;
+
     if (newState == m_currentState) {
-        return;
+        validTransition = false;
+    } else {
+        switch (m_currentState) {
+            case DialogUXStateObserverInterface::DialogUXState::THINKING:
+                if (DialogUXStateObserverInterface::DialogUXState::LISTENING == newState) {
+                    validTransition = false;
+                }
+
+                break;
+            default:
+                break;
+        }
+    }
+
+    ACSDK_DEBUG0(LX(__func__)
+                     .d("from", m_currentState)
+                     .d("to", newState)
+                     .d("validTransition", validTransition ? "true" : "false"));
+
+    if (!validTransition) {
+        return false;
     }
+
     m_listeningTimeoutTimer.stop();
     m_thinkingTimeoutTimer.stop();
     m_multiturnSpeakingToListeningTimer.stop();
-    ACSDK_DEBUG(LX("setState").d("from", m_currentState).d("to", newState));
     m_currentState = newState;
     notifyObserversOfState();
+
+    return true;
 }
 
 void DialogUXStateAggregator::tryEnterIdleState() {
@@ -285,7 +316,8 @@ void DialogUXStateAggregator::tryEnterIdleState() {
     m_thinkingTimeoutTimer.stop();
     m_multiturnSpeakingToListeningTimer.stop();
     if (!m_multiturnSpeakingToListeningTimer
-             .start(SHORT_TIMEOUT, std::bind(&DialogUXStateAggregator::tryEnterIdleStateOnTimer, this))
+             .start(
+                 m_shortTimeoutForThinkingToIdle, std::bind(&DialogUXStateAggregator::tryEnterIdleStateOnTimer, this))
              .valid()) {
         ACSDK_ERROR(LX("failedToStartTryEnterIdleStateTimer"));
     }
diff --git a/AVSCommon/AVS/src/EndpointResources.cpp b/AVSCommon/AVS/src/EndpointResources.cpp
new file mode 100644
index 00000000..efe10619
--- /dev/null
+++ b/AVSCommon/AVS/src/EndpointResources.cpp
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <algorithm>
+
+#include <AVSCommon/AVS/EndpointResources.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+using namespace avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("EndpointResources");
+
+/**
+* Create a LogEntry using this file's TAG and the specified event string.
+*
+* @param The event string for this @c LogEntry.
+*/
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/// Maximum length of the friendly name
+static constexpr size_t MAX_FRIENDLY_NAME_LENGTH = 128;
+/// Maximum length of the manufacturer name
+static constexpr size_t MAX_MANUFACTURER_NAME_LENGTH = 128;
+/// Maximum length of the description
+static constexpr size_t MAX_DESCRIPTION_LENGTH = 128;
+
+EndpointResources::EndpointResources() : m_isValid{true} {
+}
+
+bool EndpointResources::Label::operator==(const EndpointResources::Label& rhs) const {
+    return value == rhs.value && locale.valueOr("") == rhs.locale.valueOr("");
+}
+
+EndpointResources& EndpointResources::addFriendlyNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+
+    if (std::find(
+            m_friendlyNames.begin(),
+            m_friendlyNames.end(),
+            EndpointResources::Label(
+                    {Label::LabelType::ASSET, assetId, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>()})) != m_friendlyNames.end()) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "duplicateAssetId").sensitive("assetId", assetId));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_friendlyNames.push_back({Label::LabelType::ASSET, assetId, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>()});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addFriendlyNameWithText(
+        const std::string& text,
+        const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale) {
+
+        if (text.length() == 0 || text.length() > MAX_FRIENDLY_NAME_LENGTH) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidText"));
+            m_isValid = false;
+            return *this;
+        }
+        if (locale.empty()) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidLocale"));
+            m_isValid = false;
+            return *this;
+        }
+        if (std::find(
+                m_friendlyNames.begin(),
+                m_friendlyNames.end(),
+                Label({Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)})) !=
+                m_friendlyNames.end()) {
+            ACSDK_WARN(LX("addFriendlyNameWithTextFailed")
+                                .d("reason", "duplicateText")
+                                .sensitive("text", text)
+                                .sensitive("locale", locale));
+            return *this;
+        }
+
+        m_friendlyNames.push_back({Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::ASSET, assetId, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>()};
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithText(
+        const std::string& text,
+        const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_MANUFACTURER_NAME_LENGTH) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)};
+    return *this;
+};
+
+
+EndpointResources& EndpointResources::addDescriptionWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::ASSET, assetId, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>()};
+    return *this;
+};
+
+EndpointResources& EndpointResources::addDescriptionWithText(
+        const std::string& text,
+        const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_DESCRIPTION_LENGTH) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)};
+    return *this;
+};
+
+bool EndpointResources::isValid() const {
+    return m_isValid && m_friendlyNames.size() > 0 && m_description.value.length() > 0
+                     && m_manufacturerName.value.length() > 0;
+};
+
+std::string EndpointResources::build() const {
+    if (!isValid()) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return "";
+    }
+    json::JsonGenerator jsonGenerator;
+    std::vector<std::string> friendlyNames;
+    for (auto &friendlyName : m_friendlyNames){
+        friendlyNames.push_back(friendlyName.toJson());
+    }
+    jsonGenerator.addMembersArray("friendlyNames", friendlyNames);
+    jsonGenerator.addRawJsonMember("manufacturerName", m_manufacturerName.toJson());
+    jsonGenerator.addRawJsonMember("description", m_description.toJson());
+    return jsonGenerator.toString();
+};
+
+std::string EndpointResources::Label::toJson() const {
+    json::JsonGenerator scopeGenerator;
+    if (type == Label::LabelType::TEXT) {
+        scopeGenerator.addMember("@type", "text");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("text", value);
+        scopeGenerator.addMember("locale", locale.value());
+    } else if (type == Label::LabelType::ASSET) {
+        scopeGenerator.addMember("@type", "asset");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("assetId", value);
+    } else{
+        return "{}";
+    }
+    return scopeGenerator.toString();
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/test/CapabilityResourcesTest.cpp b/AVSCommon/AVS/test/CapabilityResourcesTest.cpp
index 7c836170..10541c84 100644
--- a/AVSCommon/AVS/test/CapabilityResourcesTest.cpp
+++ b/AVSCommon/AVS/test/CapabilityResourcesTest.cpp
@@ -39,6 +39,12 @@ static std::string expectedFriendlyNamesJson =
     R"({"@type":"text","value":{"text":"air conditioner","locale":"en-US"}},)"
     R"({"@type":"asset","value":{"assetId":"Alexa.Setting.Temperature"}}])"
     R"(})";
+/// The expected friendly names json with a single value.
+static std::string expectedSimpleFriendlyNameJson =
+    R"({)"
+    R"("friendlyNames":[)"
+    R"({"@type":"text","value":{"text":"fan","locale":"en-US"}}])"
+    R"(})";
 
 /**
  * The test harness for @c CapabilityResources.
@@ -100,14 +106,16 @@ TEST_F(CapabilityResourcesTest, test_addFriendlyNameWithEmptyLocale) {
 }
 
 /**
- * Test if the addFriendlyNameWithText method checks for duplicate entries.
+ * Test if the addFriendlyNameWithText method checks for duplicate entries. It should succeed but skip the duplicate.
  */
 TEST_F(CapabilityResourcesTest, test_addFriendlyNameWithDuplicateText) {
     CapabilityResources capabilityResources;
+
     ASSERT_TRUE(capabilityResources.addFriendlyNameWithText(FAN_FRIENDLY_NAME, TEST_LOCALE));
-    ASSERT_FALSE(capabilityResources.addFriendlyNameWithText(FAN_FRIENDLY_NAME, TEST_LOCALE));
-    ASSERT_FALSE(capabilityResources.isValid());
-    ASSERT_EQ(capabilityResources.toJson(), "{}");
+    ASSERT_TRUE(capabilityResources.isValid());
+    ASSERT_TRUE(capabilityResources.addFriendlyNameWithText(FAN_FRIENDLY_NAME, TEST_LOCALE));
+    ASSERT_TRUE(capabilityResources.isValid());
+    ASSERT_EQ(capabilityResources.toJson(), expectedSimpleFriendlyNameJson);
 }
 
 /**
diff --git a/AVSCommon/AVS/test/CapabilitySemanticsTest.cpp b/AVSCommon/AVS/test/CapabilitySemanticsTest.cpp
new file mode 100644
index 00000000..16d09d0d
--- /dev/null
+++ b/AVSCommon/AVS/test/CapabilitySemanticsTest.cpp
@@ -0,0 +1,223 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <AVSCommon/AVS/ActionsToDirectiveMapping.h>
+#include <AVSCommon/AVS/CapabilitySemantics.h>
+#include <gtest/gtest.h>
+#include <rapidjson/document.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+namespace test {
+
+using namespace ::testing;
+using namespace avsCommon::avs;
+
+static std::string ACTION_OPEN = "Alexa.Actions.Open";
+static std::string ACTION_CLOSE = "Alexa.Actions.Close";
+static std::string ACTION_RAISE = "Alexa.Actions.Raise";
+static std::string ACTION_LOWER = "Alexa.Actions.Lower";
+
+static std::string DIRECTIVE_SETMODE = "SetMode";
+
+// clang-format off
+static std::string PAYLOAD_SETMODE_UP = R"({
+    "mode": "Position.Up"
+})";
+
+static std::string PAYLOAD_SETMODE_DOWN = R"({
+    "mode": "Position.Down"
+})";
+
+static std::string JSON_ACTION_CLOSE_TO_DOWN = R"({
+    "@type": "ActionsToDirective",
+    "actions": ["Alexa.Actions.Close"],
+    "directive": {
+        "name": "SetMode",
+        "payload": {
+            "mode": "Position.Down"
+        }
+    }
+})";
+
+static std::string JSON_ACTION_CLOSE_LOWER_TO_DOWN = R"({
+    "@type": "ActionsToDirective",
+    "actions": ["Alexa.Actions.Close", "Alexa.Actions.Lower"],
+    "directive": {
+        "name": "SetMode",
+        "payload": {
+            "mode": "Position.Down"
+        }
+    }
+})";
+
+static std::string JSON_SEMANTICS_SINGLE_ACTION = R"({
+"actionMappings": [
+    {
+        "@type": "ActionsToDirective",
+        "actions": ["Alexa.Actions.Close"],
+        "directive": {
+            "name": "SetMode",
+            "payload": {
+                "mode": "Position.Down"
+            }
+        }
+    }
+]
+})";
+
+static std::string JSON_SEMANTICS_MULTIPLE_ACTIONS = R"({
+"actionMappings": [
+    {
+        "@type": "ActionsToDirective",
+        "actions": ["Alexa.Actions.Close", "Alexa.Actions.Lower"],
+        "directive": {
+            "name": "SetMode",
+            "payload": {
+                "mode": "Position.Down"
+            }
+        }
+    },
+    {
+        "@type": "ActionsToDirective",
+        "actions": ["Alexa.Actions.Open", "Alexa.Actions.Raise"],
+        "directive": {
+            "name": "SetMode",
+            "payload": {
+                "mode": "Position.Up"
+            }
+        }
+    }
+]
+})";
+// clang-format on
+
+/**
+ * Expects the provided JSON strings to be equal.
+ */
+void validateJson(const std::string& providedJson, const std::string& expectedJson) {
+    rapidjson::Document providedStateParsed;
+    providedStateParsed.Parse(providedJson);
+
+    rapidjson::Document expectedStateParsed;
+    expectedStateParsed.Parse(expectedJson);
+
+    EXPECT_EQ(providedStateParsed, expectedStateParsed);
+}
+
+/**
+ * The test harness for @c CapabilitySemantics.
+ */
+class CapabilitySemanticsTest : public Test {};
+
+/**
+ * Test if ActionsToDirectiveMapping::addAction() checks for an empty action.
+ */
+TEST_F(CapabilitySemanticsTest, test_addEmptyAction) {
+    ActionsToDirectiveMapping actionsMapping;
+    ASSERT_FALSE(actionsMapping.addAction(""));
+    ASSERT_FALSE(actionsMapping.isValid());
+    ASSERT_EQ(actionsMapping.toJson(), "{}");
+}
+
+/**
+ * Test if ActionsToDirectiveMapping::setDirective() checks for an empty name.
+ */
+TEST_F(CapabilitySemanticsTest, test_addEmptyDirectiveName) {
+    ActionsToDirectiveMapping actionsMapping;
+    ASSERT_FALSE(actionsMapping.setDirective("", "{}"));
+    ASSERT_FALSE(actionsMapping.isValid());
+    ASSERT_EQ(actionsMapping.toJson(), "{}");
+}
+
+/**
+ * Test if ActionsToDirectiveMapping::addAction() skips duplicate actions.
+ */
+TEST_F(CapabilitySemanticsTest, test_addDuplicateActions) {
+    ActionsToDirectiveMapping setModeDownMapping;
+    ASSERT_TRUE(setModeDownMapping.setDirective(DIRECTIVE_SETMODE, PAYLOAD_SETMODE_DOWN));
+    ASSERT_TRUE(setModeDownMapping.addAction(ACTION_CLOSE));
+    ASSERT_TRUE(setModeDownMapping.isValid());
+    ASSERT_FALSE(setModeDownMapping.addAction(ACTION_CLOSE));
+    ASSERT_FALSE(setModeDownMapping.isValid());
+    ASSERT_EQ(setModeDownMapping.toJson(), "{}");
+}
+
+/**
+ * Test the JSON result of an ActionsToDirectiveMapping with a single action in a mapping.
+ */
+TEST_F(CapabilitySemanticsTest, test_validateJson_actionMappingSingleAction) {
+    ActionsToDirectiveMapping setModeDownMapping;
+    ASSERT_TRUE(setModeDownMapping.addAction(ACTION_CLOSE));
+    ASSERT_TRUE(setModeDownMapping.setDirective(DIRECTIVE_SETMODE, PAYLOAD_SETMODE_DOWN));
+    ASSERT_TRUE(setModeDownMapping.isValid());
+    validateJson(setModeDownMapping.toJson(), JSON_ACTION_CLOSE_TO_DOWN);
+}
+
+/**
+ * Test the JSON result of an ActionsToDirectiveMapping with multiple actions in a mapping.
+ */
+TEST_F(CapabilitySemanticsTest, test_validateJson_actionMappingMultipleActions) {
+    ActionsToDirectiveMapping setModeDownMapping;
+    ASSERT_TRUE(setModeDownMapping.addAction(ACTION_CLOSE));
+    ASSERT_TRUE(setModeDownMapping.addAction(ACTION_LOWER));
+    ASSERT_TRUE(setModeDownMapping.setDirective(DIRECTIVE_SETMODE, PAYLOAD_SETMODE_DOWN));
+    ASSERT_TRUE(setModeDownMapping.isValid());
+    validateJson(setModeDownMapping.toJson(), JSON_ACTION_CLOSE_LOWER_TO_DOWN);
+}
+
+/**
+ * Test the JSON result of a CapabilitySemantics with one single-action ActionsToDirectiveMapping member.
+ */
+TEST_F(CapabilitySemanticsTest, test_validateJson_semanticsSingleActionMapping) {
+    ActionsToDirectiveMapping setModeDownMapping;
+    ASSERT_TRUE(setModeDownMapping.addAction(ACTION_CLOSE));
+    ASSERT_TRUE(setModeDownMapping.setDirective(DIRECTIVE_SETMODE, PAYLOAD_SETMODE_DOWN));
+    ASSERT_TRUE(setModeDownMapping.isValid());
+
+    CapabilitySemantics semantics;
+    ASSERT_TRUE(semantics.addActionsToDirectiveMapping(setModeDownMapping));
+    ASSERT_TRUE(semantics.isValid());
+    validateJson(semantics.toJson(), JSON_SEMANTICS_SINGLE_ACTION);
+}
+
+/**
+ * Test the JSON result of a CapabilitySemantics with multiple multi-action ActionsToDirectiveMapping members.
+ */
+TEST_F(CapabilitySemanticsTest, test_validateJson_semanticsMultipleActionMappings) {
+    ActionsToDirectiveMapping setModeDownMapping;
+    ASSERT_TRUE(setModeDownMapping.addAction(ACTION_CLOSE));
+    ASSERT_TRUE(setModeDownMapping.addAction(ACTION_LOWER));
+    ASSERT_TRUE(setModeDownMapping.setDirective(DIRECTIVE_SETMODE, PAYLOAD_SETMODE_DOWN));
+    ASSERT_TRUE(setModeDownMapping.isValid());
+
+    ActionsToDirectiveMapping setModeUpMapping;
+    ASSERT_TRUE(setModeUpMapping.addAction(ACTION_OPEN));
+    ASSERT_TRUE(setModeUpMapping.addAction(ACTION_RAISE));
+    ASSERT_TRUE(setModeUpMapping.setDirective(DIRECTIVE_SETMODE, PAYLOAD_SETMODE_UP));
+    ASSERT_TRUE(setModeUpMapping.isValid());
+
+    CapabilitySemantics semantics;
+    ASSERT_TRUE(semantics.addActionsToDirectiveMapping(setModeDownMapping));
+    ASSERT_TRUE(semantics.addActionsToDirectiveMapping(setModeUpMapping));
+    ASSERT_TRUE(semantics.isValid());
+    validateJson(semantics.toJson(), JSON_SEMANTICS_MULTIPLE_ACTIONS);
+}
+
+}  // namespace test
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
index c0862685..1dcf2b72 100644
--- a/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
+++ b/AVSCommon/AVS/test/DialogUXStateAggregatorTest.cpp
@@ -34,7 +34,7 @@ static const auto SHORT_TIMEOUT = std::chrono::milliseconds(50);
 
 /// Time out for testing if transitionFromThinking or transitionFromListneing timeouts have occurred.
 // This needs to be longer than the values passed into the DialogUXStateAggregator.
-static const auto TRANSITION_TIMEOUT = std::chrono::milliseconds(300);
+static const auto TRANSITION_TIMEOUT = std::chrono::seconds(9);
 
 /// Dummy value for a media player source id
 static const avsCommon::utils::mediaPlayer::MediaPlayerInterface::SourceId TEST_SOURCE_ID = -1;
@@ -285,7 +285,6 @@ TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveGoesToIdleAfterLongTimeou
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE, TRANSITION_TIMEOUT);
 }
 
@@ -302,8 +301,6 @@ TEST_F(DialogUXAggregatorTest, test_listeningThenReceiveThenSpeakGoesToSpeakButN
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
-
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, TEST_SOURCE_ID, m_testMediaPlayerState);
 
@@ -321,8 +318,6 @@ TEST_F(DialogUXAggregatorTest, test_speakingAndRecognizingFinishedGoesToIdle) {
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
-
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, TEST_SOURCE_ID, m_testMediaPlayerState);
 
@@ -371,8 +366,6 @@ TEST_F(DialogUXAggregatorTest, test_speakingFinishedDoesNotGoesToIdleImmediately
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
-
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, TEST_SOURCE_ID, m_testMediaPlayerState);
 
@@ -388,8 +381,6 @@ TEST_F(DialogUXAggregatorTest, test_speakingFinishedDoesNotGoesToIdleImmediately
 TEST_F(DialogUXAggregatorTest, test_simpleReceiveDoesNothing) {
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
 
-    m_aggregator->receive("", "");
-
     assertNoStateChange(m_testObserver);
 
     m_aggregator->onStateChanged(
@@ -397,8 +388,6 @@ TEST_F(DialogUXAggregatorTest, test_simpleReceiveDoesNothing) {
 
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
 
-    m_aggregator->receive("", "");
-
     assertNoStateChange(m_testObserver);
 }
 
@@ -412,16 +401,11 @@ TEST_F(DialogUXAggregatorTest, test_thinkingThenReceiveRemainsInThinkingIfSpeech
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
-
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::GAINING_FOCUS,
         TEST_SOURCE_ID,
         m_testMediaPlayerState);
 
-    // Make sure after SpeechSynthesizer reports GAINING_FOCUS, that it would stay in THINKING state
-    m_aggregator->receive("", "");
-
     assertNoStateChange(m_testObserver, TRANSITION_TIMEOUT);
 }
 
@@ -431,15 +415,13 @@ TEST_F(DialogUXAggregatorTest, test_validStatesForRPSToThinking) {
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
-    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE, TRANSITION_TIMEOUT);
     m_aggregator->onStateChanged(AudioInputProcessorObserverInterface::State::BUSY);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::LISTENING);
     m_aggregator->onRequestProcessingStarted();
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::THINKING);
 
-    m_aggregator->receive("", "");
-    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE);
+    assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::IDLE, TRANSITION_TIMEOUT);
     m_aggregator->onStateChanged(
         SpeechSynthesizerObserverInterface::SpeechSynthesizerState::PLAYING, TEST_SOURCE_ID, m_testMediaPlayerState);
     assertStateChange(m_testObserver, DialogUXStateObserverInterface::DialogUXState::SPEAKING);
diff --git a/AVSCommon/CMakeLists.txt b/AVSCommon/CMakeLists.txt
index 6cb0457b..99b00ac7 100644
--- a/AVSCommon/CMakeLists.txt
+++ b/AVSCommon/CMakeLists.txt
@@ -12,6 +12,7 @@ add_library(AVSCommon SHARED
     AVS/src/AVSMessage.cpp
     AVS/src/AVSMessageHeader.cpp
     AVS/src/AbstractAVSConnectionManager.cpp
+    AVS/src/ActionsToDirectiveMapping.cpp
     AVS/src/BlockingPolicy.cpp
     AVS/src/ExternalMediaPlayer/AdapterUtils.cpp
     AVS/src/AlexaClientSDKInit.cpp
@@ -29,6 +30,8 @@ add_library(AVSCommon SHARED
     AVS/src/EventBuilder.cpp
     AVS/src/ExceptionEncounteredSender.cpp
     AVS/src/CapabilityResources.cpp
+    AVS/src/CapabilitySemantics.cpp
+    AVS/src/EndpointResources.cpp
     AVS/src/HandlerAndPolicy.cpp
     AVS/src/MessageRequest.cpp
     AVS/src/NamespaceAndName.cpp
@@ -52,6 +55,8 @@ add_library(AVSCommon SHARED
     Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
     Utils/src/LibcurlUtils/HttpPost.cpp
     Utils/src/LibcurlUtils/HttpPut.cpp
+    Utils/src/LibcurlUtils/HttpGet.cpp
+    Utils/src/LibcurlUtils/HttpDelete.cpp
     Utils/src/LibcurlUtils/HTTPResponse.cpp
     Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
     Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
index db20c72e..5c4e9895 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
@@ -41,17 +41,30 @@ public:
         NONE
     };
 
+    /// Information about the call to display on screen-based devices when the observer is notified of a call state change.
+    struct CallDisplayInfo {
+        /// The contact name to be displayed.
+        std::string displayName;
+        /// Information about the endpoint of the contact (work/mobile/home etc.).
+        std::string endpointLabel;
+        /// Contains name of callee for whom incoming call is intended. This field is not populated for Alexa/Skype calls currently.
+        std::string inboundCalleeName;
+        /// Textual description of exact call provider type (e.g. "Alexa Call", "Skype Call" etc.).
+        std::string callProviderType;
+    };
+
     /**
      * Destructor
      */
     virtual ~CallStateObserverInterface() = default;
 
     /**
-     * Allows the observer to react to a change in call state.
+     * Allows the observer to react to a change in call state with display info for the call.
      *
      * @param state The new CallState.
+     * @param displayInfo Information to be used for display on screen-based devices.
      */
-    virtual void onCallStateChange(CallState state) = 0;
+    virtual void onCallStateChange(CallState state, const CallDisplayInfo& displayInfo) = 0;
 
     /**
      * Checks the state of the provided call state to determine if a call is in an "active" state
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
index 04c5935c..3e1cc35c 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
@@ -97,6 +97,10 @@ public:
      */
     virtual std::string getDialogRequestId() = 0;
 
+    virtual void setIsDialogRequestOnline(bool isOnline) = 0;
+
+    virtual bool isDialogRequestOnline() = 0;
+
     /**
      * Sequence the handling of an @c AVSDirective.  The actual handling is done by whichever @c DirectiveHandler
      * is associated with the most specific routing rule.
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
index 7295a979..7cefde5c 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
@@ -19,6 +19,7 @@
 #include <memory>
 #include <string>
 
+#include "AVSCommon/AVS/EndpointResources.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributes.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerInterface.h"
@@ -131,18 +132,32 @@ public:
      * @note This value can contain up to 128 characters.
      * @note The builder will fail if the manufacturer name param is invalid.
      *
-     * @param description The manufacturer name of the device representing the endpoint.
+     * @param manufacturerName The manufacturer name of the device representing the endpoint.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withManufacturerName(const std::string& manufacturerName) = 0;
 
+    /**
+     * Configures builder to use endpointResources representing the endpoint.
+     *
+     * @note EndpointResources contains friendlyNames, manufacturer name and description.
+     * @note Use either withFriendlyName, withDescription, withManufacturerName to build or withEndpointResources
+     * to build. 
+     * @note The builder will fail if the endpointResources param is invalid.
+     *
+     * @param endpointResources The endpointResources of the device representing the endpoint.
+     * @return This builder which can be used to nest configuration function calls.
+     */
+    virtual EndpointBuilderInterface& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) = 0;
+
     /**
      * Configures builder to use the following display categories.
      *
      * @note This will override any previous display categories configuration.
      * @note The builder will fail if the displayCategories param is invalid.
      *
-     * @param description The display category the device belongs to.
+     * @param displayCategories The display category the device belongs to.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withDisplayCategory(const std::vector<std::string>& displayCategories) = 0;
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
index 42ad8e47..95a6ed87 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
@@ -258,6 +258,17 @@ public:
         const std::string& channelName,
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver) = 0;
 
+    /**
+     * This method will release the Channel without specifying the observer and notify the current observer of the 
+     * Channel to stop via ChannelObserverInterface##onFocusChanged(). If the Channel to release is the current 
+     * foreground focused Channel, it will also notify the next highest priority Channel via a 
+     * ChannelObserverInterface##onFocusChanged() callback that it has gained foreground focus.
+     *
+     * @param channelName The name of the Channel to release.
+     * @return Returns @c true if the Channel can be released and @c false otherwise.
+     */
+    virtual bool releaseChannel(const std::string& channelName) = 0;    
+
     /**
      * This method will request that the currently foregrounded Channel activity be stopped, if there is one. This will
      * be performed asynchronously, and so, if at the time of processing, the activity has stopped for any reason, then
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
new file mode 100644
index 00000000..80258547
--- /dev/null
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
+
+#include <string>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace sdkInterfaces {
+namespace messaging {
+
+/**
+ * This @c MessagingObserverInterface class is used to notify observers when a @c SendMessage,
+ * @c UpdateMessageStatus, or @c UploadConversations directive is received.
+ */
+class MessagingObserverInterface {
+public:
+    /**
+     * An enum representing the messaging endpoints.
+     */
+    enum class MessagingEndpoint {
+        /// Default messaging endpoint
+        DEFAULT
+    };
+
+    /**
+     * Destructor
+     */
+    virtual ~MessagingObserverInterface() = default;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.SendMessage directive
+     * is received. Once called, the client should send the message to the given recipients
+     * using the specified messaging endpoint.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint to send the message.
+     * @param jsonPayload The payload of the @c SendMessage directive in structured JSON format.
+     * @code{.json}
+     * {
+     *     "payload": {
+     *         "@type" : "text",
+     *         "text" : "{{STRING}}"
+     *     },
+     *     "recipients" : [
+     *         {
+     *             "address" : "{{STRING}}",
+     *             "addressType" : "PhoneNumberAddress"
+     *         }
+     *     ]
+     * }
+     * @endcode
+     *
+     */
+    virtual void sendMessage(const std::string& token, MessagingEndpoint endpoint, const std::string& jsonPayload) = 0;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.UploadConversations directive
+     * is received. Once called, the client should upload a conversations report using the specified
+     * filter in the JSON payload.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint whose messages are requested to be uploaded.
+     * @param jsonPayload The payload of the @c UploadConversations directive in structured JSON format. The only
+     * supported filter values are shown below.
+     * @code{.json}
+     * {
+     *     "filter" : {
+     *         "conversationFilter" : {
+     *             "@type" : "AllConversations",
+     *             "conversationIds" : [{{STRING}}]
+     *         },
+     *         "messageFilter" : {
+     *             "@type" : "UnreadMessages"
+     *         },
+     *         "maxMessageCount" : 40
+     *      }
+     * }
+     * @endcode
+     *
+     */
+    virtual void uploadConversations(
+        const std::string& token,
+        MessagingEndpoint endpoint,
+        const std::string& jsonPayload) = 0;
+
+    /**
+     * Used to notify the observer when a @c Alexa.Comms.MessagingController.UpdateMessagesStatus directive
+     * is received. Once called, the client should update the specified messages with the given
+     * status.
+     *
+     * @param token The token for this request.
+     * @param endpoint The messaging endpoint whose messages status need to be updated.
+     * @param jsonPayload The payload of the @c UpdateMessagesStatus directive in structured JSON format.
+     * @code{.json}
+     * {
+     *     "conversationId" : {{STRING}},
+     *     "statusMap" : {
+     *         "read" : [{{STRING}}],
+     *     }
+     * }
+     * @endcode
+     */
+    virtual void updateMessagesStatus(
+        const std::string& token,
+        MessagingEndpoint endpoint,
+        const std::string& jsonPayload) = 0;
+};
+
+}  // namespace messaging
+}  // namespace sdkInterfaces
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MESSAGING_MESSAGINGOBSERVERINTERFACE_H_
\ No newline at end of file
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributeBuilderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributeBuilderInterface.h
index d342e771..ce05a7aa 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributeBuilderInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributeBuilderInterface.h
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 #define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MODECONTROLLER_MODECONTROLLERATTRIBUTEBUILDERINTERFACE_H_
 
 #include <AVSCommon/AVS/CapabilityResources.h>
+#include <AVSCommon/AVS/CapabilitySemantics.h>
 #include <AVSCommon/Utils/Optional.h>
 
 #include "ModeControllerAttributes.h"
@@ -84,6 +85,16 @@ public:
      */
     virtual ModeControllerAttributeBuilderInterface& setOrdered(bool ordered) = 0;
 
+    /**
+     * Configures the builder to use the specified semantics definition.
+     * @see https://developer.amazon.com/en-US/docs/alexa/device-apis/alexa-modecontroller.html#semantics
+     *
+     * @param semantics The @c CapabilitySemantics representing the semantics definition.
+     * @return This builder, which can be used to nest configuration function calls.
+     */
+    virtual ModeControllerAttributeBuilderInterface& withSemantics(
+        const avsCommon::avs::CapabilitySemantics& semantics) = 0;
+
     /**
      * Builds a @c ModeControllerAttributes with the configured properties.
      *
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributes.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributes.h
index 9eb6df28..b69d8eeb 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributes.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributes.h
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -17,8 +17,11 @@
 #define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_MODECONTROLLER_MODECONTROLLERATTRIBUTES_H_
 
 #include <unordered_map>
+#include <vector>
 
 #include <AVSCommon/AVS/CapabilityResources.h>
+#include <AVSCommon/AVS/CapabilitySemantics.h>
+#include <AVSCommon/Utils/Optional.h>
 
 namespace alexaClientSDK {
 namespace avsCommon {
@@ -54,6 +57,20 @@ struct ModeControllerAttributes {
         const std::unordered_map<std::string, ModeResources>& modes,
         bool ordered);
 
+    /**
+     *  Constructor to build the @c ModeControllerAttributes using provided values.
+     *
+     *  @param capabilityResources The capability resources.
+     *  @param modes A map of controller modes and mode resources.
+     *  @param ordered A boolean indicating the ordering of @c modes.
+     *  @param semantics The optional semantics definition.
+     */
+    ModeControllerAttributes(
+        const avsCommon::avs::CapabilityResources& capabilityResources,
+        const std::unordered_map<std::string, ModeResources>& modes,
+        bool ordered,
+        avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> semantics);    
+
     /// A capability resource @c CapabilityResources
     const avsCommon::avs::CapabilityResources capabilityResources;
 
@@ -62,6 +79,9 @@ struct ModeControllerAttributes {
 
     /// If @c true indicates that the modes in @c modes are ordered.
     const bool ordered;
+
+    /// A semantics definition as an @c Optional @c CapabilitySemantics
+    avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> semantics;
 };
 
 inline ModeControllerAttributes::ModeControllerAttributes() :
@@ -77,7 +97,19 @@ inline ModeControllerAttributes::ModeControllerAttributes(
     bool ordered) :
         capabilityResources{capabilityResources},
         modes{modes},
-        ordered{ordered} {
+        ordered{ordered},
+        semantics{avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics>()} {
+}
+
+inline ModeControllerAttributes::ModeControllerAttributes(
+    const avsCommon::avs::CapabilityResources& capabilityResources,
+    const std::unordered_map<std::string, ModeResources>& modes,
+    bool ordered,
+    avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> semantics) :
+        capabilityResources{capabilityResources},
+        modes{modes},
+        ordered{ordered},
+        semantics{semantics} {
 }
 
 }  // namespace modeController
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/RangeController/RangeControllerAttributeBuilderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/RangeController/RangeControllerAttributeBuilderInterface.h
index 3dd41b1e..64354b46 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/RangeController/RangeControllerAttributeBuilderInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/RangeController/RangeControllerAttributeBuilderInterface.h
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 #define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_RANGECONTROLLER_RANGECONTROLLERATTRIBUTEBUILDERINTERFACE_H_
 
 #include <AVSCommon/AVS/CapabilityResources.h>
+#include <AVSCommon/AVS/CapabilitySemantics.h>
 #include <AVSCommon/Utils/Optional.h>
 
 #include "RangeControllerAttributes.h"
@@ -75,6 +76,16 @@ public:
     virtual RangeControllerAttributeBuilderInterface& addPreset(
         const std::pair<double, avsCommon::sdkInterfaces::rangeController::PresetResources>& preset) = 0;
 
+    /**
+     * Configures the builder to use the specified semantics definition.
+     * @see https://developer.amazon.com/en-US/docs/alexa/device-apis/alexa-modecontroller.html#semantics
+     *
+     * @param semantics The @c CapabilitySemantics representing the semantics definition.
+     * @return This builder, which can be used to nest configuration function calls.
+     */
+    virtual RangeControllerAttributeBuilderInterface& withSemantics(
+        const avsCommon::avs::CapabilitySemantics& semantics) = 0;
+    
     /**
      * Builds a @c RangeControllerAttributes with the configured properties.
      *
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/RangeController/RangeControllerAttributes.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/RangeController/RangeControllerAttributes.h
index 16f2169f..3bad4866 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/RangeController/RangeControllerAttributes.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/RangeController/RangeControllerAttributes.h
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 #define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_RANGECONTROLLER_RANGECONTROLLERATTRIBUTES_H_
 
 #include <AVSCommon/AVS/CapabilityResources.h>
+#include <AVSCommon/AVS/CapabilitySemantics.h>
 #include <AVSCommon/AVS/AlexaUnitOfMeasure.h>
 #include <AVSCommon/Utils/Optional.h>
 
@@ -54,6 +55,20 @@ struct RangeControllerAttributes {
         const utils::Optional<avsCommon::avs::resources::AlexaUnitOfMeasure>& unitOfMeasure,
         const std::vector<std::pair<double, avsCommon::sdkInterfaces::rangeController::PresetResources>>& presets);
 
+    /**
+     *  Constructor to build the @c RangeControllerAttributes using provided values.
+     *
+     *  @param capabilityResources The capability resources.
+     *  @param unitOfMeasure The unit of measure of range defined using @c AlexaUnitOfMeasure
+     *  @param presets presets of the range controller.
+     *  @param semantics The optional semantics definition.
+     */
+    RangeControllerAttributes(
+        const avsCommon::avs::CapabilityResources& capabilityResources,
+        const utils::Optional<avsCommon::avs::resources::AlexaUnitOfMeasure>& unitOfMeasure,
+        const std::vector<std::pair<double, avsCommon::sdkInterfaces::rangeController::PresetResources>>& presets,
+        avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> semantics);
+
     /// A capability resource @c CapabilityResources
     const avsCommon::avs::CapabilityResources capabilityResources;
 
@@ -65,6 +80,9 @@ struct RangeControllerAttributes {
      * PresetResources.
      */
     std::vector<std::pair<double, avsCommon::sdkInterfaces::rangeController::PresetResources>> presets;
+
+    /// A semantics definition as an @c Optional @c CapabilitySemantics
+    avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> semantics;
 };
 
 inline RangeControllerAttributes::RangeControllerAttributes() {
@@ -76,7 +94,19 @@ inline RangeControllerAttributes::RangeControllerAttributes(
     const std::vector<std::pair<double, avsCommon::sdkInterfaces::rangeController::PresetResources>>& presets) :
         capabilityResources{capabilityResources},
         unitOfMeasure{unitOfMeasure},
-        presets{presets} {
+        presets{presets},
+        semantics{avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics>()} {
+}
+
+inline RangeControllerAttributes::RangeControllerAttributes(
+    const avsCommon::avs::CapabilityResources& capabilityResources,
+    const utils::Optional<avsCommon::avs::resources::AlexaUnitOfMeasure>& unitOfMeasure,
+    const std::vector<std::pair<double, avsCommon::sdkInterfaces::rangeController::PresetResources>>& presets,
+    avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> semantics) :
+        capabilityResources{capabilityResources},
+        unitOfMeasure{unitOfMeasure},
+        presets{presets},
+        semantics{semantics} {
 }
 
 }  // namespace rangeController
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ToggleController/ToggleControllerAttributeBuilderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ToggleController/ToggleControllerAttributeBuilderInterface.h
index 925e39a0..88db71d1 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ToggleController/ToggleControllerAttributeBuilderInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ToggleController/ToggleControllerAttributeBuilderInterface.h
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 #define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_TOGGLECONTROLLER_TOGGLECONTROLLERATTRIBUTEBUILDERINTERFACE_H_
 
 #include <AVSCommon/AVS/CapabilityResources.h>
+#include <AVSCommon/AVS/CapabilitySemantics.h>
 #include <AVSCommon/Utils/Optional.h>
 
 #include "ToggleControllerAttributes.h"
@@ -52,6 +53,16 @@ public:
     virtual ToggleControllerAttributeBuilderInterface& withCapabilityResources(
         const avsCommon::avs::CapabilityResources& capabilityResources) = 0;
 
+    /**
+     * Configures the builder to use the specified semantics definition.
+     * @see https://developer.amazon.com/en-US/docs/alexa/device-apis/alexa-modecontroller.html#semantics
+     *
+     * @param semantics The @c CapabilitySemantics representing the semantics definition.
+     * @return This builder, which can be used to nest configuration function calls.
+     */
+    virtual ToggleControllerAttributeBuilderInterface& withSemantics(
+        const avsCommon::avs::CapabilitySemantics& semantics) = 0;
+
     /**
      * Builds a @c ToggleControllerAttributes with the configured properties.
      *
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ToggleController/ToggleControllerAttributes.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ToggleController/ToggleControllerAttributes.h
index abfd4692..a7291b39 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ToggleController/ToggleControllerAttributes.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/ToggleController/ToggleControllerAttributes.h
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -17,6 +17,8 @@
 #define ALEXA_CLIENT_SDK_AVSCOMMON_SDKINTERFACES_INCLUDE_AVSCOMMON_SDKINTERFACES_TOGGLECONTROLLER_TOGGLECONTROLLERATTRIBUTES_H_
 
 #include <AVSCommon/AVS/CapabilityResources.h>
+#include <AVSCommon/AVS/CapabilitySemantics.h>
+#include <AVSCommon/Utils/Optional.h>
 
 namespace alexaClientSDK {
 namespace avsCommon {
@@ -24,12 +26,55 @@ namespace sdkInterfaces {
 namespace toggleController {
 
 /**
- * The toggle controller attribute containing the capability resources required for
+ * The Toggle Controller attributes containing the capability resources required for
  * Capability Agent discovery.
  *
  * @see https://developer.amazon.com/docs/alexa/alexa-voice-service/alexa-togglecontroller.html#capability-assertion
  */
-using ToggleControllerAttributes = avsCommon::avs::CapabilityResources;
+struct ToggleControllerAttributes {
+    /**
+     * Default constructor.
+     *
+     * @note Avoid using this method. This was added only to enable the to use @c Optional::value().
+     */
+    ToggleControllerAttributes() = default;
+
+    /**
+     * Constructor to build the @c ToggleControllerAttributes using provided values.
+     *
+     * @param capabilityResources The capability resources.
+     */
+    ToggleControllerAttributes(const avsCommon::avs::CapabilityResources& capabilityResources);
+
+    /**
+     * Constructor to build the @c ToggleControllerAttributes using provided values.
+     *
+     * @param capabilityResources The capability resources.
+     * @param semantics The optional semantics definition.
+     */
+    ToggleControllerAttributes(
+        const avsCommon::avs::CapabilityResources& capabilityResources,
+        avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> semantics);
+
+    /// The capability resources as @c CapabilityResources
+    const avsCommon::avs::CapabilityResources capabilityResources;
+
+    /// A semantics definition as an @c Optional @c CapabilitySemantics
+    avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> semantics;
+};
+
+inline ToggleControllerAttributes::ToggleControllerAttributes(
+    const avsCommon::avs::CapabilityResources& capabilityResources) : 
+    capabilityResources{capabilityResources},
+    semantics{avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics>()} {
+}
+
+inline ToggleControllerAttributes::ToggleControllerAttributes(
+    const avsCommon::avs::CapabilityResources& capabilityResources,
+    avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> semantics) : 
+    capabilityResources{capabilityResources},
+    semantics{semantics} {
+}
 
 }  // namespace toggleController
 }  // namespace sdkInterfaces
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
index a1461998..f568cff3 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
@@ -37,6 +37,10 @@ public:
     inline std::string getDialogRequestId() {
         return m_dialogRequestId;
     };
+	
+	MOCK_METHOD0(isDialogRequestOnline, bool());
+    MOCK_METHOD1(setIsDialogRequestOnline, void(bool));
+	
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
     MOCK_METHOD0(doShutdown, void());
     MOCK_METHOD0(disable, void());
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h
index 1308fc50..a1e89356 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h
@@ -44,6 +44,7 @@ public:
             const std::string& channelName,
             std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver));
     MOCK_METHOD0(stopForegroundActivity, void());
+    MOCK_METHOD1(releaseChannel, bool(const std::string& channelName));
     MOCK_METHOD1(
         addObserver,
         void(const std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerObserverInterface>& observer));
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
index 8458bd82..843edbba 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
@@ -73,7 +73,9 @@ public:
         /// HTTP POST
         kPOST,
         /// HTTP PUT
-        kPUT
+        kPUT,
+        /// HTTP DELETE
+        kDELETE
     };
 
     /**
@@ -254,6 +256,27 @@ public:
      */
     CURLcode pause(int mask);
 
+    /**
+     * Static function to set the network interface to be used for the curl
+     * connection.
+     *
+     * Network interface provided will be used in preference over the value
+     * in provided in config. Set emtpy string to reset to default.
+     *
+     * @note The network interace set shall applied only to newly instantiated
+     * @c CurlEasyHandleWrapper objects.
+     *
+     * @param value The interface name as defined in CURLOPT_INTERFACE.
+     */
+    static void setInterfaceName(const std::string& interfaceName);
+
+    /**
+     * Static function to get the network interface.
+     *
+     * @returns the current network interface, otherwise an empty string.
+     */
+    static std::string getInterfaceName();
+
 private:
     /**
      * Frees and sets the following attributes to NULL:
@@ -300,6 +323,9 @@ private:
     avsCommon::utils::logger::LogStringFormatter m_logFormatter;
 #endif
 
+    /// Initializes the @c m_interfaceName  from config.
+    static void initializeNetworkInterfaceName();
+
     /// The associated libcurl easy handle
     CURL* m_handle;
     /// A list of headers needed to be added at the HTTP level
@@ -312,7 +338,12 @@ private:
     curl_httppost* m_lastPost;
     /// Name for this handle.
     std::string m_id;
-
+    /// Synchronizes access to the @c m_interfaceName
+    static std::mutex m_interfaceNameMutex;
+    /// Indicates the initialization of @c m_interfaceName
+    static bool m_isInterfaceNameInitialized;
+    /// Interface name to be used for curl
+    static std::string m_interfaceName;
     /// If no id is provided by the user, we will generate it from this counter.
     static std::atomic<uint64_t> m_idGenerator;
 };
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
new file mode 100644
index 00000000..bff624b6
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpDeleteInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpDeleteInterface.
+class HttpDelete : public HttpDeleteInterface {
+public:
+    /**
+     * Create a new HttpDelete instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpDelete instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpDelete> create();
+
+    /**
+     * HttpDelete destructor
+     */
+    ~HttpDelete() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpDelete(const HttpDelete& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpDelete& operator=(const HttpDelete& rhs) = delete;
+
+    HTTPResponse doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout) override;
+
+private:
+    /**
+     * Default HttpDelete constructor.
+     */
+    HttpDelete() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
new file mode 100644
index 00000000..14459fa6
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+
+#include <chrono>
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP DELETE requests.
+class HttpDeleteInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpDeleteInterface() = default;
+
+    /**
+     * Perform an HTTP DELETE request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the DELETE to.
+     * @param headers vector of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
+     * @return An object describing the response to the DELETE request.
+     */
+    virtual HTTPResponse doDelete(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
new file mode 100644
index 00000000..f19dfd6e
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpGetInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpGetInterface.
+class HttpGet : public HttpGetInterface {
+public:
+    /**
+     * Create a new HttpGet instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpGet instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpGet> create();
+
+    /**
+     * HttpGet destructor
+     */
+    ~HttpGet() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpGet(const HttpGet& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpGet& operator=(const HttpGet& rhs) = delete;
+
+    HTTPResponse doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout) override;
+
+private:
+    /**
+     * Default HttpGet constructor.
+     */
+    HttpGet() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
new file mode 100644
index 00000000..68573f06
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+
+#include <chrono>
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP GET requests.
+class HttpGetInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpGetInterface() = default;
+
+    /**
+     * Perform an HTTP Get request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the GET to.
+     * @param headers vector of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
+     * @return An object describing the response to the GET request.
+     */
+    virtual HTTPResponse doGet(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
index ec70c280..758a213d 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Logger/ThreadMoniker.h
@@ -39,7 +39,7 @@ public:
      *
      * @return The moniker for @c std::this_thread.
      */
-    static inline std::string getThisThreadMoniker();
+    static inline const char* getThisThreadMoniker();
 
     /**
      * Generate a unique moniker.
@@ -52,7 +52,8 @@ public:
      * Set the moniker for @c std::this_thread. This method should be called before @c getThisThreadMoniker() in order
      * to take effect.
      *
-     * @param moniker The moniker for @c std::this_thread.
+     * @param moniker The moniker for @c std::this_thread. The maximum length of the moniker is 15 characters. Any
+     * characters beyond the limit will be truncated.
      */
     static inline void setThisThreadMoniker(const std::string& moniker);
 
@@ -81,10 +82,10 @@ private:
     static const ThreadMoniker& getMonikerObjectFromMap(const std::string& moniker = std::string());
 
     /// The current thread's moniker.
-    std::string m_moniker;
+    char m_moniker[16];
 };
 
-std::string ThreadMoniker::getThisThreadMoniker() {
+const char* ThreadMoniker::getThisThreadMoniker() {
     return getMonikerObject().m_moniker;
 }
 
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h
index 99c7e251..4eab4b77 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Threading/Executor.h
@@ -166,7 +166,11 @@ auto Executor::submitToFront(Task task, Args&&... args) -> std::future<decltype(
  */
 template <typename T>
 inline static void forwardPromise(std::shared_ptr<std::promise<T>> promise, std::future<T>* future) {
-    promise->set_value(future->get());
+    try {
+        promise->set_value(future->get());
+    } catch (...) {
+        promise->set_exception(std::current_exception());
+    }
 }
 
 /**
@@ -177,8 +181,12 @@ inline static void forwardPromise(std::shared_ptr<std::promise<T>> promise, std:
  */
 template <>
 inline void forwardPromise<void>(std::shared_ptr<std::promise<void>> promise, std::future<void>* future) {
-    future->get();
-    promise->set_value();
+    try {
+        future->get();
+        promise->set_value();
+    } catch (...) {
+        promise->set_exception(std::current_exception());
+    }
 }
 
 template <typename Task, typename... Args>
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/Timing/Timer.h b/AVSCommon/Utils/include/AVSCommon/Utils/Timing/Timer.h
index 8f5c05e4..a936eadd 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/Timing/Timer.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/Timing/Timer.h
@@ -165,13 +165,14 @@ public:
 
     /**
      * Stops the @c Timer (if running).  This will not interrupt an active call to the task, but will prevent any
-     * subequent calls to the task.  If @c stop() is called while the task is executing, this function will block until
-     * the task completes.
+     * subsequent calls to the task.  If @c stop() is called while the task is executing, this function will block until
+     * the task completes if the @c wait parameter is true.
      *
+     * @param wait Whether the caller should block until the task completes
      * @note In the special case that @c stop() is called from inside the task function, @c stop() will still prevent
      *     any subsequent calls to the task, but will *not* block as described above.
      */
-    void stop();
+    void stop(bool wait = true);
 
     /**
      * Reports whether the @c Timer is active.  A timer is considered active if it is waiting to start a call to the
diff --git a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
index fdfb346b..2b2e874c 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
@@ -54,6 +54,12 @@ static const std::string LIBCURLUTILS_CONFIG_KEY = "libcurlUtils";
 static const std::string INTERFACE_CONFIG_KEY = "CURLOPT_INTERFACE";
 /// Counter used to geneate unique IDs.
 std::atomic<uint64_t> CurlEasyHandleWrapper::m_idGenerator{1};
+///  Interface used for the curl connection.
+std::string CurlEasyHandleWrapper::m_interfaceName{""};
+/// Indicates the initialization of @c m_interfaceName
+bool CurlEasyHandleWrapper::m_isInterfaceNameInitialized = false;
+/// Synchronizes access to the @c m_interfaceName
+std::mutex CurlEasyHandleWrapper::m_interfaceNameMutex;
 
 #ifdef ACSDK_EMIT_CURL_LOGS
 /// Key under 'acl' configuration node for path/prefix of per-stream log file names.
@@ -242,6 +248,9 @@ bool CurlEasyHandleWrapper::setTransferType(TransferType type) {
         case TransferType::kPUT:
             ret = setopt(CURLOPT_UPLOAD, 1L);
             break;
+        case TransferType::kDELETE:
+            ret = setopt(CURLOPT_CUSTOMREQUEST, "DELETE");
+            break;
     }
     return ret;
 }
@@ -322,10 +331,14 @@ bool CurlEasyHandleWrapper::setDefaultOptions() {
             break;
         }
 
-        auto config = configuration::ConfigurationNode::getRoot()[LIBCURLUTILS_CONFIG_KEY];
-        std::string interfaceName;
-        if (config.getString(INTERFACE_CONFIG_KEY, &interfaceName) &&
-            !setopt(CURLOPT_INTERFACE, interfaceName.c_str())) {
+        {
+            std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
+            if (!m_isInterfaceNameInitialized) {
+                initializeNetworkInterfaceName();
+            }
+        }
+
+        if (!m_interfaceName.empty() && !setopt(CURLOPT_INTERFACE, m_interfaceName.c_str())) {
             break;
         }
 
@@ -372,6 +385,41 @@ CURLcode CurlEasyHandleWrapper::pause(int mask) {
     return CURLcode::CURLE_FAILED_INIT;
 }
 
+void CurlEasyHandleWrapper::setInterfaceName(const std::string& interfaceName) {
+    std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
+    ACSDK_DEBUG(LX("setInterfaceName").d("interfaceName", interfaceName));
+
+    if (interfaceName.empty()) {
+        m_interfaceName = interfaceName;
+        // Reset to default value from config, if provided.
+        initializeNetworkInterfaceName();
+        return;
+    }
+    m_interfaceName = interfaceName;
+}
+
+std::string CurlEasyHandleWrapper::getInterfaceName() {
+    std::lock_guard<std::mutex> lock(m_interfaceNameMutex);
+    if (!m_isInterfaceNameInitialized) {
+        initializeNetworkInterfaceName();
+    }
+    return m_interfaceName;
+}
+
+void CurlEasyHandleWrapper::initializeNetworkInterfaceName() {
+    auto config = configuration::ConfigurationNode::getRoot()[LIBCURLUTILS_CONFIG_KEY];
+    std::string interfaceNameFromConfig;
+    config.getString(INTERFACE_CONFIG_KEY, &interfaceNameFromConfig, "");
+
+    if (m_interfaceName.empty() && !interfaceNameFromConfig.empty()) {
+        // Update the value from config, so that getInterfaceName always
+        // return the current value.
+        m_interfaceName = interfaceNameFromConfig;
+    }
+    m_isInterfaceNameInitialized = true;
+    ACSDK_DEBUG(LX("initializeNetworkInterfaceName").d("m_interfaceName", m_interfaceName));
+}
+
 #ifdef ACSDK_EMIT_CURL_LOGS
 void CurlEasyHandleWrapper::initStreamLog() {
     std::string streamLogPrefix;
@@ -437,7 +485,7 @@ int CurlEasyHandleWrapper::debugFunction(CURL* handle, curl_infotype type, char*
         (*stream->m_streamLog) << logFormatter.format(
                                       logger::Level::INFO,
                                       std::chrono::system_clock::now(),
-                                      logger::ThreadMoniker::getThisThreadMoniker().c_str(),
+                                      logger::ThreadMoniker::getThisThreadMoniker(),
                                       curlInfoTypeToString(type))
                                << std::endl;
         if (CURLINFO_TEXT == type) {
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
new file mode 100644
index 00000000..129fca85
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpDelete.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpDelete");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpDelete> HttpDelete::create() {
+    std::unique_ptr<HttpDelete> httpDelete(new HttpDelete());
+    if (httpDelete->m_curl.isValid()) {
+        return httpDelete;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpDelete::doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doDeleteFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kDELETE)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
new file mode 100644
index 00000000..10e6836a
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpGet.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpGet");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpGet> HttpGet::create() {
+    std::unique_ptr<HttpGet> httpGet(new HttpGet());
+    if (httpGet->m_curl.isValid()) {
+        return httpGet;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpGet::doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doGetFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kGET)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp b/AVSCommon/Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
index 406599c2..2e166144 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
@@ -300,6 +300,17 @@ std::unique_ptr<avsCommon::utils::HTTPContent> LibCurlHttpContentFetcher::getCon
         stateTransition(State::ERROR, false);
         return nullptr;
     }
+
+    // Use HTTP1.1 if url is not https
+    if (m_url.find("https") != 0) {
+        curlReturnValue = curl_easy_setopt(m_curlWrapper.getCurlHandle(), CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);
+        if (curlReturnValue != CURLE_OK) {
+            ACSDK_ERROR(LX("getContentFailed").d("reason", "setHttpVersion").d("error", curlReturnValue));
+            stateTransition(State::ERROR, false);
+            return nullptr;
+        }
+    }
+
     if (!m_curlWrapper.setConnectionTimeout(TIMEOUT_CONNECTION)) {
         ACSDK_ERROR(LX("getContentFailed").d("reason", "setConnectionTimeoutFailed"));
         stateTransition(State::ERROR, false);
diff --git a/AVSCommon/Utils/src/Logger/ConsoleLogger.cpp b/AVSCommon/Utils/src/Logger/ConsoleLogger.cpp
index 1f8a9a9c..7001360b 100644
--- a/AVSCommon/Utils/src/Logger/ConsoleLogger.cpp
+++ b/AVSCommon/Utils/src/Logger/ConsoleLogger.cpp
@@ -56,7 +56,7 @@ ConsoleLogger::ConsoleLogger() : Logger(Level::UNKNOWN) {
     emit(
         alexaClientSDK::avsCommon::utils::logger::Level::INFO,
         std::chrono::system_clock::now(),
-        ThreadMoniker::getThisThreadMoniker().c_str(),
+        ThreadMoniker::getThisThreadMoniker(),
         currentVersionLogEntry.c_str());
 }
 
diff --git a/AVSCommon/Utils/src/Logger/Logger.cpp b/AVSCommon/Utils/src/Logger/Logger.cpp
index 1145dc34..95ad89c8 100644
--- a/AVSCommon/Utils/src/Logger/Logger.cpp
+++ b/AVSCommon/Utils/src/Logger/Logger.cpp
@@ -36,7 +36,7 @@ Logger::Logger(Level level) : m_level{level} {
 
 void Logger::log(Level level, const LogEntry& entry) {
     if (shouldLog(level)) {
-        emit(level, std::chrono::system_clock::now(), ThreadMoniker::getThisThreadMoniker().c_str(), entry.c_str());
+        emit(level, std::chrono::system_clock::now(), ThreadMoniker::getThisThreadMoniker(), entry.c_str());
     }
 }
 
diff --git a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
index 363ae08b..98e2ac93 100644
--- a/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
+++ b/AVSCommon/Utils/src/Logger/ThreadMoniker.cpp
@@ -14,6 +14,7 @@
  */
 
 #include <atomic>
+#include <cstring>
 #include <iomanip>
 #include <mutex>
 #include <sstream>
@@ -30,7 +31,9 @@ namespace logger {
 /// Counter to generate (small) unique thread monikers.
 static std::atomic<int> g_nextThreadMoniker(1);
 
-ThreadMoniker::ThreadMoniker(const std::string& moniker) : m_moniker{moniker.empty() ? generateMoniker() : moniker} {
+ThreadMoniker::ThreadMoniker(const std::string& moniker) : m_moniker{} {
+    auto& m = moniker.empty() ? generateMoniker() : moniker;
+    std::strncpy(m_moniker, m.c_str(), sizeof(m_moniker) - 1);
 }
 
 std::string ThreadMoniker::generateMoniker() {
diff --git a/AVSCommon/Utils/src/Timer.cpp b/AVSCommon/Utils/src/Timer.cpp
index bab3a556..58ab7a3c 100644
--- a/AVSCommon/Utils/src/Timer.cpp
+++ b/AVSCommon/Utils/src/Timer.cpp
@@ -27,7 +27,7 @@ Timer::~Timer() {
     stop();
 }
 
-void Timer::stop() {
+void Timer::stop(bool wait) {
     {
         std::lock_guard<std::mutex> lock(m_waitMutex);
         if (m_running) {
@@ -36,7 +36,9 @@ void Timer::stop() {
         m_waitCondition.notify_all();
     }
 
-    if (std::this_thread::get_id() != m_thread.get_id() && m_thread.joinable()) {
+    if (std::this_thread::get_id() == m_thread.get_id()) {
+        m_thread.detach(); // otherwise the timer may destruct before the thread exits completely
+    } else if (m_thread.joinable() && wait) {
         m_thread.join();
     }
 }
diff --git a/AVSGatewayManager/src/Storage/AVSGatewayManagerStorage.cpp b/AVSGatewayManager/src/Storage/AVSGatewayManagerStorage.cpp
index 422f2189..eea2caba 100644
--- a/AVSGatewayManager/src/Storage/AVSGatewayManagerStorage.cpp
+++ b/AVSGatewayManager/src/Storage/AVSGatewayManagerStorage.cpp
@@ -158,12 +158,6 @@ void AVSGatewayManagerStorage::clear() {
                                 .d("table", VERIFICATION_STATE_TABLE)
                                 .d("component", COMPONENT_NAME)
                                 .m("Please clear the table for proper future functioning."));
-            } else if (!m_miscStorage->deleteTable(COMPONENT_NAME, VERIFICATION_STATE_TABLE)) {
-                ACSDK_ERROR(LX("clearFailed")
-                                .d("reason", "Unable to delete the table")
-                                .d("table", VERIFICATION_STATE_TABLE)
-                                .d("component", COMPONENT_NAME)
-                                .m("Please delete the table for proper future functioning."));
             }
         }
     } else {
diff --git a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
index 1717076a..6559b539 100644
--- a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
+++ b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
@@ -435,7 +435,7 @@ bool DefaultClient::initialize(
      * the other networking components into one easy-to-use component.
      */
     m_connectionManager = acl::AVSConnectionManager::create(
-        m_messageRouter, false, connectionObservers, {m_dialogUXStateAggregator}, internetConnectionMonitor);
+        m_messageRouter, false, connectionObservers, {}, internetConnectionMonitor);
     if (!m_connectionManager) {
         ACSDK_ERROR(LX("initializeFailed").d("reason", "unableToCreateConnectionManager"));
         return false;
@@ -822,6 +822,7 @@ bool DefaultClient::initialize(
         m_exceptionSender,
         m_playbackRouter,
         audioChannelVolumeInterfaces,
+        m_certifiedSender,
 #ifdef ENABLE_CAPTIONS
         m_captionManager,
 #else
diff --git a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
index ac231abc..f33ca007 100644
--- a/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
+++ b/CapabilitiesDelegate/include/CapabilitiesDelegate/CapabilitiesDelegate.h
@@ -192,6 +192,9 @@ private:
     /// The mutex to serialize access to the endpoint config map.
     std::mutex m_endpointMapMutex;
 
+    /// A list that preserves the endpointId order.
+    std::vector<std::string> m_endpointsOrderList;
+
     /// A map from endpoint ID to endpoint configuration.
     std::unordered_map<std::string, std::string> m_endpointIdToConfigMap;
 
diff --git a/CapabilitiesDelegate/include/CapabilitiesDelegate/PostConnectCapabilitiesPublisher.h b/CapabilitiesDelegate/include/CapabilitiesDelegate/PostConnectCapabilitiesPublisher.h
index 7ff560d3..a83b3386 100644
--- a/CapabilitiesDelegate/include/CapabilitiesDelegate/PostConnectCapabilitiesPublisher.h
+++ b/CapabilitiesDelegate/include/CapabilitiesDelegate/PostConnectCapabilitiesPublisher.h
@@ -58,7 +58,8 @@ public:
     static std::shared_ptr<PostConnectCapabilitiesPublisher> create(
         const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
         const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
-        const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate);
+        const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate,
+        const std::vector<std::string>& endpointOrderList = {});
 
     /**
      * Destructor.
@@ -98,7 +99,8 @@ private:
     PostConnectCapabilitiesPublisher(
         const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
         const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
-        const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate);
+        const std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface>& authDelegate,
+        const std::vector<std::string>& endpointOrderList = {});
 
     /**
      * Sends the discovery event while taking into account retries.
@@ -200,6 +202,9 @@ private:
     /// Auth delegate used to get the access token
     std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> m_authDelegate;
 
+    /// The endpoint order list
+    std::vector<std::string> m_endpointsOrderList;
+
     /// The authDelegate's auth status.
     AuthObserverInterface::State m_currentAuthState;
 
diff --git a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
index e53552ba..4c92910c 100644
--- a/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
+++ b/CapabilitiesDelegate/src/CapabilitiesDelegate.cpp
@@ -198,6 +198,7 @@ bool CapabilitiesDelegate::registerEndpoint(
     } else {
         std::string endpointConfigJson = getEndpointConfigJson(endpointAttributes, capabilities);
         m_endpointIdToConfigMap.insert({endpointId, endpointConfigJson});
+        m_endpointsOrderList.push_back(endpointId);
     }
 
     return true;
@@ -217,6 +218,7 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
 
     std::unordered_map<std::string, std::string> addOrUpdateEndpointIdToConfigPairs;
     std::unordered_map<std::string, std::string> deletedEndpointIdToConfigPairs;
+    std::vector<std::string> endpointOrderList;
     ACSDK_DEBUG5(LX(__func__).d("num of endpoints registered", m_endpointIdToConfigMap.size()));
 
     std::unordered_map<std::string, std::string> storedEndpointConfig;
@@ -253,13 +255,15 @@ std::shared_ptr<PostConnectOperationInterface> CapabilitiesDelegate::createPostC
         for (auto& it : storedEndpointConfig) {
             deletedEndpointIdToConfigPairs.insert({it.first, getDeleteReportEndpointConfigJson(it.first)});
         }
+
+        endpointOrderList = m_endpointsOrderList;
     }
 
     if (addOrUpdateEndpointIdToConfigPairs.empty() && deletedEndpointIdToConfigPairs.empty()) {
         ACSDK_DEBUG5(LX(__func__).m("No change in Capabilities, skipping post connect step"));
     } else {
         auto instance = PostConnectCapabilitiesPublisher::create(
-            addOrUpdateEndpointIdToConfigPairs, deletedEndpointIdToConfigPairs, m_authDelegate);
+            addOrUpdateEndpointIdToConfigPairs, deletedEndpointIdToConfigPairs, m_authDelegate, endpointOrderList);
 
         if (instance) {
             addDiscoveryEventSender(instance);
diff --git a/CapabilitiesDelegate/src/PostConnectCapabilitiesPublisher.cpp b/CapabilitiesDelegate/src/PostConnectCapabilitiesPublisher.cpp
index 1f9b989e..f93bff88 100644
--- a/CapabilitiesDelegate/src/PostConnectCapabilitiesPublisher.cpp
+++ b/CapabilitiesDelegate/src/PostConnectCapabilitiesPublisher.cpp
@@ -52,7 +52,16 @@ static const std::vector<int> RETRY_TABLE = {
 static avsCommon::utils::RetryTimer RETRY_TIMER{RETRY_TABLE};
 
 /// Maximum number of endpoints per event.
-static const int MAX_ENDPOINTS_PER_EVENT = 300;
+static constexpr int MAX_ENDPOINTS_PER_ADD_OR_UPDATE_REPORT_EVENT = 300;
+
+/// Maximum size of the Discovery event (256 KB)
+static constexpr int MAX_DISCOVERY_PAYLOAD_SIZE = 256 * 1024;
+
+/// Maximum size of header and scope fields in the Discovery event (Choosing a sufficiently large size of 10KB).
+static constexpr int MAX_DISCOVERY_HEADER_AND_SCOPE_SIZE = 10 * 1024;
+
+/// Maximum size of endpoint configurations in Event payload.
+static constexpr int MAX_ENDPOINTS_SIZE_IN_PAYLOAD = MAX_DISCOVERY_PAYLOAD_SIZE - MAX_DISCOVERY_HEADER_AND_SCOPE_SIZE;
 
 /// The timeout for the Asynchronous response directive (Alexa.EventProcessed) to be received.
 static const auto ASYNC_RESPONSE_TIMEOUT = std::chrono::seconds(2);
@@ -60,14 +69,15 @@ static const auto ASYNC_RESPONSE_TIMEOUT = std::chrono::seconds(2);
 std::shared_ptr<PostConnectCapabilitiesPublisher> PostConnectCapabilitiesPublisher::create(
     const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
     const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
-    const std::shared_ptr<AuthDelegateInterface>& authDelegate) {
+    const std::shared_ptr<AuthDelegateInterface>& authDelegate,
+    const std::vector<std::string>& endpointOrderList) {
     if (addOrUpdateReportEndpoints.empty() && deleteReportEndpoints.empty()) {
         ACSDK_ERROR(LX("createFailed").d("reason", "endpoint map empty"));
     } else if (!authDelegate) {
         ACSDK_ERROR(LX("createFailed").d("reason", "invalid auth delegate"));
     } else {
         auto instance = std::shared_ptr<PostConnectCapabilitiesPublisher>(
-            new PostConnectCapabilitiesPublisher(addOrUpdateReportEndpoints, deleteReportEndpoints, authDelegate));
+            new PostConnectCapabilitiesPublisher(addOrUpdateReportEndpoints, deleteReportEndpoints, authDelegate, endpointOrderList));
 
         return instance;
     }
@@ -77,10 +87,12 @@ std::shared_ptr<PostConnectCapabilitiesPublisher> PostConnectCapabilitiesPublish
 PostConnectCapabilitiesPublisher::PostConnectCapabilitiesPublisher(
     const std::unordered_map<std::string, std::string>& addOrUpdateReportEndpoints,
     const std::unordered_map<std::string, std::string>& deleteReportEndpoints,
-    const std::shared_ptr<AuthDelegateInterface>& authDelegate) :
+    const std::shared_ptr<AuthDelegateInterface>& authDelegate,
+    const std::vector<std::string>& endpointOrderList) :
         m_addOrUpdateReportEndpoints{addOrUpdateReportEndpoints},
         m_deleteReportEndpoints{deleteReportEndpoints},
         m_authDelegate{authDelegate},
+        m_endpointsOrderList{endpointOrderList},
         m_currentAuthState{AuthObserverInterface::State::UNINITIALIZED},
         m_isStopping{false},
         m_isPerformOperationInvoked{false} {
@@ -124,7 +136,7 @@ MessageRequestObserverInterface::Status PostConnectCapabilitiesPublisher::sendDi
     const std::shared_ptr<PostConnectSendMessageInterface>& postConnectSender,
     const std::string& eventString,
     bool waitForEventProcessed) {
-    ACSDK_DEBUG5(LX(__func__));
+    ACSDK_DEBUG5(LX(__func__).sensitive("discoveryEvent", eventString));
     std::unique_lock<std::mutex> lock{m_mutex};
     m_eventProcessedWaitEvent.reset();
     m_postConnectRequest.reset();
@@ -200,21 +212,55 @@ bool PostConnectCapabilitiesPublisher::sendDiscoveryEvents(
     const std::vector<std::string>& endpointConfigurations,
     const std::shared_ptr<avsCommon::sdkInterfaces::PostConnectSendMessageInterface>& postConnectSender,
     bool isAddOrUpdateReportEvent) {
-    int numFullEndpoints = endpointConfigurations.size() / MAX_ENDPOINTS_PER_EVENT;
+    int currentEventSize = 0;
+    int numEndpointsInCurrentEvent = 0;
+    std::vector<std::string> currentEndpointConfigurationsBuffer;
+    auto currentEndpointConfigIt = endpointConfigurations.begin();
+
+    while (currentEndpointConfigIt != endpointConfigurations.end()) {
+        int currentEndpointConfigSize = currentEndpointConfigIt->size();
 
-    /// Send events with MAX_ENDPOINTS_PER_EVENT.
-    auto it = endpointConfigurations.begin();
-    for (int num = 0; num < numFullEndpoints; ++num) {
-        std::vector<std::string> endpointConfigs(it, it + MAX_ENDPOINTS_PER_EVENT);
-        if (!sendDiscoveryEventWithRetries(postConnectSender, endpointConfigs, isAddOrUpdateReportEvent)) {
+        // Check if the endpointConfig is too big.
+        if (currentEndpointConfigSize > MAX_ENDPOINTS_SIZE_IN_PAYLOAD) {
+            ACSDK_ERROR(LX("sendDiscoveryEvents").d("reason", "endpointConfig too big"));
             return false;
         }
-        it += MAX_ENDPOINTS_PER_EVENT;
+
+        bool sendEvent = false;
+
+        // Check for maximum allowed endpoints in Discovery.AddOrUpdateReport event.
+        if (isAddOrUpdateReportEvent) {
+            if (numEndpointsInCurrentEvent == MAX_ENDPOINTS_PER_ADD_OR_UPDATE_REPORT_EVENT) {
+                sendEvent = true;
+            }
+        }
+
+        // Check for endpoint config size in payload
+        if (currentEventSize + currentEndpointConfigSize > MAX_ENDPOINTS_SIZE_IN_PAYLOAD) {
+            sendEvent = true;
+        }
+
+        if (sendEvent) {
+            if (!sendDiscoveryEventWithRetries(
+                postConnectSender, currentEndpointConfigurationsBuffer, isAddOrUpdateReportEvent)) {
+                return false;
+            }
+
+            // Reset buffer
+            currentEventSize = 0;
+            numEndpointsInCurrentEvent = 0;
+            currentEndpointConfigurationsBuffer.clear();
+        }
+
+        currentEndpointConfigurationsBuffer.push_back(*currentEndpointConfigIt);
+        currentEventSize += currentEndpointConfigSize;
+        numEndpointsInCurrentEvent++;
+
+        currentEndpointConfigIt++;
     }
 
-    /// Send events with the remaining endpoints.
-    std::vector<std::string> endpointConfigs(it, endpointConfigurations.end());
-    return sendDiscoveryEventWithRetries(postConnectSender, endpointConfigs, isAddOrUpdateReportEvent);
+    // Send the remaining endpoints.
+    return sendDiscoveryEventWithRetries(postConnectSender, currentEndpointConfigurationsBuffer, isAddOrUpdateReportEvent);
 }
 
 bool PostConnectCapabilitiesPublisher::sendAddOrUpdateReportEvents(
@@ -227,8 +273,18 @@ bool PostConnectCapabilitiesPublisher::sendAddOrUpdateReportEvents(
     }
     /// Collect all endpoint configurations
     std::vector<std::string> allEndpointConfigs;
-    for (const auto& endpointIdToConfigPair : m_addOrUpdateReportEndpoints) {
-        allEndpointConfigs.push_back(endpointIdToConfigPair.second);
+
+    if (!m_endpointsOrderList.empty()) {
+        /// Look into the endpoints map in the order of the m_endpointsOrderList
+        for (const auto& endpointId : m_endpointsOrderList) {
+            if (m_addOrUpdateReportEndpoints.find(endpointId) != m_addOrUpdateReportEndpoints.end()) {
+                allEndpointConfigs.push_back(m_addOrUpdateReportEndpoints[endpointId]);
+            }
+        }
+    } else {
+        for (const auto& endpointIdToConfigPair : m_addOrUpdateReportEndpoints) {
+            allEndpointConfigs.push_back(endpointIdToConfigPair.second);
+        }
     }
 
     return sendDiscoveryEvents(allEndpointConfigs, postConnectSender, true);
diff --git a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
index f19eaad0..9f95def0 100644
--- a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
+++ b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
@@ -67,6 +67,8 @@ const static std::string FRIENDLY_NAME_KEY = "friendlyName";
 const static std::string DESCRIPTION_KEY = "description";
 /// Manufacturer name key
 const static std::string MANUFACTURER_NAME_KEY = "manufacturerName";
+/// EndpointResources ID key
+const static std::string ENDPOINTRESOURCES_KEY = "endpointResources";
 /// Display Categories key
 const static std::string DISPLAY_CATEGORIES_KEY = "displayCategories";
 /// Additional Attributes key
@@ -226,14 +228,18 @@ bool validateEndpointAttributes(const AVSDiscoveryEndpointAttributes& endpointAt
         return false;
     }
 
-    if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
-        return false;
-    }
+    if (!endpoints::isEndpointResourcesValid(endpointAttributes.endpointResources)) {
 
-    if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
-        return false;
+    // Validate the legacy fields if the endpointResources object is invalid.
+        if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
+            return false;
+        }
+
+        if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
+            return false;
+        }
     }
 
     if (endpointAttributes.displayCategories.empty()) {
@@ -250,9 +256,15 @@ std::string getEndpointConfigJson(
     JsonGenerator generator;
 
     generator.addMember(ENDPOINT_ID_KEY, endpointAttributes.endpointId);
-    generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
-    generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
-    generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+
+    /// Endpoint Resources.
+    if (endpointAttributes.endpointResources.isValid()) {
+        generator.addRawJsonMember(ENDPOINTRESOURCES_KEY, endpointAttributes.endpointResources.build());
+    } else {
+        generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
+        generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
+        generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+    }
 
     generator.addStringArray(DISPLAY_CATEGORIES_KEY, endpointAttributes.displayCategories);
 
diff --git a/CapabilitiesDelegate/test/PostConnectCapabilitiesPublisherTest.cpp b/CapabilitiesDelegate/test/PostConnectCapabilitiesPublisherTest.cpp
index 59e3c5ab..4ff52cb9 100644
--- a/CapabilitiesDelegate/test/PostConnectCapabilitiesPublisherTest.cpp
+++ b/CapabilitiesDelegate/test/PostConnectCapabilitiesPublisherTest.cpp
@@ -90,8 +90,10 @@ static const std::vector<std::string> EXPECTED_DELETE_ENDPOINT_IDS = {TEST_ENDPO
 static const std::string TEST_EVENT_CORRELATION_TOKEN = "TEST_EVENT_CORRELATION_TOKEN";
 /// The test retry count.
 static const int TEST_RETRY_COUNT = 2;
-/// Maximum number of endpoints that can be sent in a Discovery event.
-static const int MAX_ENDPOINTS_PER_EVENT = 300;
+/// Maximum number of endpoints that can be sent in a Discovery.AddOrUpdateReport event.
+static constexpr int MAX_ENDPOINTS_PER_ADD_OR_UPDATE_REPORT_EVENT = 300;
+/// Maximum size of Discovery event (246KB)
+static constexpr int MAX_ENDPOINTS_SIZE_IN_PAYLOAD = 246 * 1024;
 
 /**
  * Structure to store event data from a discovery event JSON.
@@ -401,11 +403,24 @@ TEST_F(PostConnectCapabilitiesPublisherTest, test_performOperationFailsWhenCalle
 /**
  * This method returns the number of Discovery Events the given endpoints will be split into.
  *
- * @param numEndpoints The totol number of endpoints
+ * @param numEndpoints The total number of endpoints.
  * @return The number of discovery events these endpoints will be split into.
  */
-static int getExpecetedNumberOfDiscoveryEvents(int numEndpoints) {
-    return numEndpoints / MAX_ENDPOINTS_PER_EVENT + ((numEndpoints % MAX_ENDPOINTS_PER_EVENT) != 0);
+static inline int getExpectedNumberOfDiscoveryEventsFromEndpointNum(int numEndpoints) {
+    return numEndpoints / MAX_ENDPOINTS_PER_ADD_OR_UPDATE_REPORT_EVENT +
+           ((numEndpoints % MAX_ENDPOINTS_PER_ADD_OR_UPDATE_REPORT_EVENT) != 0);
+}
+
+/**
+ * This method returns the number of Discovery Events the given endpoints will be spit into based on the endpoint
+ * payload size.
+ *
+ * @param endpointPayloadSize The total size of the endpoint payload.
+ * @return The number of discovery events that need to be created.
+ */
+static inline int getExpectedNumberOfDiscoveryEventFromPayloadSize(int endpointPayloadSize) {
+    return endpointPayloadSize / MAX_ENDPOINTS_SIZE_IN_PAYLOAD +
+           ((endpointPayloadSize % MAX_ENDPOINTS_SIZE_IN_PAYLOAD) != 0);
 }
 
 /**
@@ -415,7 +430,7 @@ TEST_F(PostConnectCapabilitiesPublisherTest, test_performOperationSplitsEventsWi
     std::unordered_map<std::string, std::string> addOrUpdateReportEndpoints, deleteReportEndpoints;
     std::string endpointIdPrefix = "ENDPOINT_ID_";
     int testNumAddOrUpdateReportEndpoints = 1400;
-    int testNumDeleteReportEndpoints = 299;
+    int testNumDeleteReportEndpoints = 400;
 
     for (int i = 1; i <= testNumAddOrUpdateReportEndpoints; ++i) {
         std::string endpointId = endpointIdPrefix + std::to_string(i);
@@ -450,8 +465,8 @@ TEST_F(PostConnectCapabilitiesPublisherTest, test_performOperationSplitsEventsWi
         request->sendCompleted(MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED);
     };
 
-    int expectedNumOfAddOrUpdateReportEvents = getExpecetedNumberOfDiscoveryEvents(testNumAddOrUpdateReportEndpoints);
-    int expectedNumOfDeleteReportEvents = getExpecetedNumberOfDiscoveryEvents(testNumDeleteReportEndpoints);
+    int expectedNumOfAddOrUpdateReportEvents = getExpectedNumberOfDiscoveryEventsFromEndpointNum(testNumAddOrUpdateReportEndpoints);
+    int expectedNumOfDeleteReportEvents = 1;
     {
         InSequence s;
         EXPECT_CALL(*m_mockPostConnectSendMessage, sendPostConnectMessage(_))
@@ -479,6 +494,83 @@ TEST_F(PostConnectCapabilitiesPublisherTest, test_performOperationSplitsEventsWi
     postConnectCapabilitiesPublisher->removeDiscoveryStatusObserver(m_mockDiscoveryStatusObserver);
 }
 
+/**
+ * Test if multiple discovery events are sent if the max payload size is reached.
+ */
+TEST_F(PostConnectCapabilitiesPublisherTest, test_sendDiscoveryEventsSplitsEventsWhenMaxPayloadSizeIsReached) {
+    std::unordered_map<std::string, std::string> addOrUpdateReportEndpoints, deleteReportEndpoints;
+    std::string endpointIdPrefix = "ENDPOINT_ID_";
+    int testNumAddOrUpdateReportEndpoints = 400;
+    int testNumDeleteReportEndpoints = 301;
+
+    /// Create a large endpointConfig string (2KB)
+    std::string testLargeEndpointConfig(2048, 'X');
+
+    for (int i = 1; i <= testNumAddOrUpdateReportEndpoints; ++i) {
+        std::string endpointId = endpointIdPrefix + std::to_string(i);
+        std::string endpointIdConfig = "{\"endpointId\":\"" + testLargeEndpointConfig + "\"}";
+        addOrUpdateReportEndpoints.insert({endpointId, endpointIdConfig});
+    }
+
+    for (int i = 1; i <= testNumDeleteReportEndpoints; ++i) {
+        std::string endpointId = endpointIdPrefix + std::to_string(i);
+        std::string endpointIdConfig = "{\"endpointId\":\"" + testLargeEndpointConfig + "\"}";
+        deleteReportEndpoints.insert({endpointId, endpointIdConfig});
+    }
+
+    auto postConnectCapabilitiesPublisher =
+        PostConnectCapabilitiesPublisher::create(addOrUpdateReportEndpoints, deleteReportEndpoints, m_mockAuthDelegate);
+
+    postConnectCapabilitiesPublisher->addDiscoveryStatusObserver(m_mockDiscoveryStatusObserver);
+
+    auto handleAddOrUpdateReport = [postConnectCapabilitiesPublisher](std::shared_ptr<MessageRequest> request) {
+      EventData eventData;
+      ASSERT_TRUE(parseEventJson(request->getJsonContent(), &eventData));
+      validateDiscoveryEvent(eventData, ADD_OR_UPDATE_REPORT_NAME);
+
+      request->sendCompleted(MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED);
+      postConnectCapabilitiesPublisher->onAlexaEventProcessedReceived(eventData.eventCorrelationTokenString);
+    };
+
+    auto handleDeleteReport = [](std::shared_ptr<MessageRequest> request) {
+      EventData eventData;
+      ASSERT_TRUE(parseEventJson(request->getJsonContent(), &eventData));
+      validateDiscoveryEvent(eventData, DELETE_REPORT_NAME);
+      request->sendCompleted(MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED);
+    };
+
+    int expectedNumOfAddOrUpdateReportEvents =
+        getExpectedNumberOfDiscoveryEventFromPayloadSize(testNumAddOrUpdateReportEndpoints * 2048);
+    int expectedNumOfDeleteReportEvents =
+        getExpectedNumberOfDiscoveryEventFromPayloadSize(testNumDeleteReportEndpoints * 2048);
+    {
+        InSequence s;
+        EXPECT_CALL(*m_mockPostConnectSendMessage, sendPostConnectMessage(_))
+            .Times(expectedNumOfAddOrUpdateReportEvents)
+            .WillRepeatedly(Invoke(handleAddOrUpdateReport));
+        EXPECT_CALL(*m_mockPostConnectSendMessage, sendPostConnectMessage(_))
+            .Times(expectedNumOfDeleteReportEvents)
+            .WillRepeatedly(Invoke(handleDeleteReport));
+    }
+
+    EXPECT_CALL(*m_mockDiscoveryStatusObserver, onDiscoveryCompleted(addOrUpdateReportEndpoints, deleteReportEndpoints))
+        .WillOnce(Return());
+
+    EXPECT_CALL(*m_mockAuthDelegate, addAuthObserver(_))
+        .WillOnce(InvokeWithoutArgs([&postConnectCapabilitiesPublisher]() {
+          postConnectCapabilitiesPublisher->onAuthStateChange(
+              AuthObserverInterface::State::REFRESHED, AuthObserverInterface::Error::SUCCESS);
+        }));
+    EXPECT_CALL(*m_mockAuthDelegate, getAuthToken()).WillRepeatedly(Return(TEST_AUTH_TOKEN));
+    EXPECT_CALL(*m_mockAuthDelegate, removeAuthObserver(_)).WillRepeatedly(Return());
+
+    ASSERT_TRUE(postConnectCapabilitiesPublisher->performOperation(m_mockPostConnectSendMessage));
+
+    /// cleanup
+    postConnectCapabilitiesPublisher->removeDiscoveryStatusObserver(m_mockDiscoveryStatusObserver);
+}
+
+
 /**
  * Test when AddOrUpdateReport response is 202 and DeleteReport response is 4xx.
  */
diff --git a/CapabilityAgents/AIP/src/AudioInputProcessor.cpp b/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
index aa2a2e26..d424cfda 100644
--- a/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
+++ b/CapabilityAgents/AIP/src/AudioInputProcessor.cpp
@@ -1130,7 +1130,6 @@ bool AudioInputProcessor::executeStopCapture(bool stopImmediately, std::shared_p
         return true;
     }
     if (m_state != ObserverInterface::State::RECOGNIZING) {
-        static const char* errorMessage = "StopCapture only allowed in RECOGNIZING state.";
         auto returnValue = false;
         if (info) {
             if (info->result) {
@@ -1143,7 +1142,7 @@ bool AudioInputProcessor::executeStopCapture(bool stopImmediately, std::shared_p
                                    .m("StopCapture directive ignored because local StopCapture was performed."));
 
                 } else {
-                    info->result->setFailed(errorMessage);
+                    info->result->setCompleted();
                     ACSDK_ERROR(LX("executeStopCaptureFailed")
                                     .d("reason", "invalidState")
                                     .d("expectedState", "RECOGNIZING")
diff --git a/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp b/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
index 620b4f76..ff6751e0 100644
--- a/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
+++ b/CapabilityAgents/AIP/test/AudioInputProcessorTest.cpp
@@ -615,7 +615,6 @@ TestDialogUXStateObserver::TestDialogUXStateObserver(
 
 void TestDialogUXStateObserver::onDialogUXStateChanged(DialogUXState newState) {
     if (DialogUXState::THINKING == newState) {
-        m_aggregator->receive("", "");
     }
 }
 
diff --git a/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h b/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
index ad6b291b..f9fd1f9d 100644
--- a/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
+++ b/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
@@ -74,6 +74,29 @@ public:
         State state,
         const std::string& reason = "") = 0;
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    virtual void onAlertCreated(const std::string& alertToken, const std::string& detailedInfo) {};
+
+    /**
+     * A callback function to notify an object that an alert has been deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    virtual void onAlertDeleted(const std::string& alertToken) {};
+
     /**
      * Convert a @c State to a @c std::string.
      *
diff --git a/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h b/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
index 468b682f..b372d4f4 100644
--- a/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
+++ b/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
@@ -299,6 +299,32 @@ private:
         AlertObserverInterface::State state,
         const std::string& reason);
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    void executeOnAlertCreated(
+        const std::string& alertToken,
+        const std::string& jsonPayload);
+
+    /**
+     * A handler function which will be called by our internal executor when an alert is deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    void executeOnAlertDeleted(
+        const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to add an alert observer.
      *
@@ -327,6 +353,21 @@ private:
         AlertObserverInterface::State state,
         const std::string& reason = "");
 
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of detailed alert info.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     * @param jsonInfo The detailed JSON info. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertCreatedObservers(const std::string& alertToken, const std::string& jsonInfo);
+
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of an alert deleted.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertDeletedObservers(const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to remove all alerts currently being managed.
      */
diff --git a/CapabilityAgents/Alerts/include/Alerts/Renderer/Renderer.h b/CapabilityAgents/Alerts/include/Alerts/Renderer/Renderer.h
index cb3540bb..a5299247 100644
--- a/CapabilityAgents/Alerts/include/Alerts/Renderer/Renderer.h
+++ b/CapabilityAgents/Alerts/include/Alerts/Renderer/Renderer.h
@@ -25,6 +25,7 @@
 #include <AVSCommon/Utils/MediaPlayer/MediaPlayerObserverInterface.h>
 #include <AVSCommon/Utils/MediaPlayer/SourceConfig.h>
 #include <AVSCommon/Utils/MediaType.h>
+#include <AVSCommon/Utils/RequiresShutdown.h>
 
 #include <chrono>
 #include <condition_variable>
@@ -42,7 +43,9 @@ namespace renderer {
  */
 class Renderer
         : public RendererInterface
-        , public avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface {
+        , public avsCommon::utils::mediaPlayer::MediaPlayerObserverInterface
+        , public avsCommon::utils::RequiresShutdown
+        , public std::enable_shared_from_this<Renderer> {
 public:
     /**
      * Creates a @c Renderer.
@@ -260,6 +263,11 @@ private:
 
     /// @}
 
+    /// @name RequiresShutdown methods
+    /// @{
+    void doShutdown() override;
+    /// @}
+
     /**
      * @name Executor Thread Variables
      *
diff --git a/CapabilityAgents/Alerts/src/AlertScheduler.cpp b/CapabilityAgents/Alerts/src/AlertScheduler.cpp
index 5194f0a8..6e5d38b6 100644
--- a/CapabilityAgents/Alerts/src/AlertScheduler.cpp
+++ b/CapabilityAgents/Alerts/src/AlertScheduler.cpp
@@ -367,6 +367,9 @@ void AlertScheduler::shutdown() {
     m_alertStorage.reset();
     m_alertRenderer.reset();
     m_activeAlert.reset();
+    for (auto& alert : m_scheduledAlerts) {
+        alert->setRenderer(nullptr);
+    }
     m_scheduledAlerts.clear();
 }
 
diff --git a/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp b/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
index ede3e59e..5cc7a747 100644
--- a/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
+++ b/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
@@ -68,6 +68,9 @@ static const std::string ALERTS_CAPABILITY_INTERFACE_VERSION = "1.4";
 /// The value for Type which we need for json parsing.
 static const std::string KEY_TYPE = "type";
 
+/// The value for Label which we need for json parsing.
+static const std::string KEY_LABEL = "label";
+
 // ==== Directives ===
 
 /// The value of the SetAlert Directive.
@@ -582,6 +585,27 @@ bool AlertsCapabilityAgent::handleSetAlert(
 
     updateContextManager();
 
+    Document document( rapidjson::kObjectType );
+    document.AddMember("time", parsedAlert->getScheduledTime_ISO_8601(), document.GetAllocator());
+    document.AddMember("type", parsedAlert->getTypeName(), document.GetAllocator());
+    std::string label;
+    if (!retrieveValue(payload, KEY_LABEL, &label)) {
+        document.AddMember("label", "", document.GetAllocator());
+    } else {
+        document.AddMember("label", label, document.GetAllocator());
+    }
+    // build the json state string
+    rapidjson::StringBuffer buffer;
+    rapidjson::Writer<rapidjson::StringBuffer> writer( buffer );
+
+    if (!document.Accept( writer )) {
+        ACSDK_ERROR(LX("failedToWriteJsonDocument").m("Alert DetailedInfo not sent"));
+    } else {
+        std::string payload = buffer.GetString();
+        std::string token = parsedAlert->getToken();
+        m_executor.submit([this, token, payload]() { executeOnAlertCreated( token, payload); });
+    }
+
     return true;
 }
 
@@ -603,6 +627,9 @@ bool AlertsCapabilityAgent::handleDeleteAlert(
     submitMetric(m_metricRecorder, "failedToDeleteAlert", 0);
     updateContextManager();
 
+    std::string token = *alertToken;
+    m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
+
     return true;
 }
 
@@ -632,6 +659,8 @@ bool AlertsCapabilityAgent::handleDeleteAlerts(
         if (!convertToValue(tokenArray[i], &token)) {
             ACSDK_WARN(LX("handleDeleteAlertsFailed").d("reason", "invalid token in payload"));
             continue;
+        } else {
+            m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
         }
         alertTokens.push_back(token);
     }
@@ -1018,6 +1047,14 @@ void AlertsCapabilityAgent::executeOnAlertStateChange(
     });
 }
 
+void AlertsCapabilityAgent::executeOnAlertCreated(const std::string& alertToken, const std::string& payload){
+    m_executor.submit([this, alertToken, payload]() { executeNotifyAlertCreatedObservers(alertToken, payload); });
+}
+
+void AlertsCapabilityAgent::executeOnAlertDeleted(const std::string& alertToken){
+    m_executor.submit([this, alertToken]() { executeNotifyAlertDeletedObservers(alertToken); });
+}
+
 void AlertsCapabilityAgent::executeAddObserver(std::shared_ptr<AlertObserverInterface> observer) {
     ACSDK_DEBUG1(LX("executeAddObserver").d("observer", observer.get()));
     m_observers.insert(observer);
@@ -1043,6 +1080,23 @@ void AlertsCapabilityAgent::executeNotifyObservers(
     }
 }
 
+void AlertsCapabilityAgent::executeNotifyAlertCreatedObservers(
+    const std::string& alertToken,
+    const std::string& payload) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertCreatedObservers").d("alertToken", alertToken).sensitive("payload", payload));
+    for (auto observer : m_observers) {
+        observer->onAlertCreated(alertToken, payload);
+    }
+}
+
+void AlertsCapabilityAgent::executeNotifyAlertDeletedObservers(
+    const std::string& alertToken) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertDeletedObservers").d("alertToken", alertToken));
+    for (auto observer : m_observers) {
+        observer->onAlertDeleted(alertToken);
+    }
+}
+
 void AlertsCapabilityAgent::executeRemoveAllAlerts() {
     ACSDK_DEBUG1(LX("executeRemoveAllAlerts"));
     m_alertScheduler.clearData();
diff --git a/CapabilityAgents/Alerts/src/Renderer/Renderer.cpp b/CapabilityAgents/Alerts/src/Renderer/Renderer.cpp
index 670c14ec..4dfe0ec4 100644
--- a/CapabilityAgents/Alerts/src/Renderer/Renderer.cpp
+++ b/CapabilityAgents/Alerts/src/Renderer/Renderer.cpp
@@ -60,11 +60,20 @@ std::shared_ptr<Renderer> Renderer::create(std::shared_ptr<MediaPlayerInterface>
         return nullptr;
     }
 
-    auto renderer = std::shared_ptr<Renderer>(new Renderer{mediaPlayer});
+    std::shared_ptr<Renderer> renderer(new Renderer(mediaPlayer));
     mediaPlayer->addObserver(renderer);
     return renderer;
 }
 
+void Renderer::doShutdown() {
+    ACSDK_DEBUG5(LX(__func__));
+
+    if (m_mediaPlayer) {
+        m_mediaPlayer->removeObserver(shared_from_this());
+    }
+    m_executor.shutdown();
+}
+
 void Renderer::start(
     std::shared_ptr<RendererObserverInterface> observer,
     std::function<std::pair<std::unique_ptr<std::istream>, const avsCommon::utils::MediaType>()> audioFactory,
@@ -130,6 +139,7 @@ void Renderer::onPlaybackError(
 }
 
 Renderer::Renderer(std::shared_ptr<MediaPlayerInterface> mediaPlayer) :
+        RequiresShutdown{"Renderer"},
         m_mediaPlayer{mediaPlayer},
         m_observer{nullptr},
         m_numberOfStreamsRenderedThisLoop{0},
diff --git a/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h b/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h
index 668a7dc2..e5b9d5fb 100644
--- a/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h
+++ b/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h
@@ -46,6 +46,7 @@
 #include <AVSCommon/Utils/Timing/Timer.h>
 #include <AVSCommon/Utils/Timing/TimeUtils.h>
 #include <Captions/CaptionManagerInterface.h>
+#include <CertifiedSender/CertifiedSender.h>
 
 #include "AudioItem.h"
 #include "ClearBehavior.h"
@@ -92,6 +93,7 @@ public:
      * @param audioChannelVolumeInterfaces A list of @c ChannelVolumeInterface instances to use to control/attenuate
      * channel volume. These instances are required for controlling volume for the @c MediaPlayerInterface instances
      * created by @param mediaPlayerFactory.
+     * @param certifiedMessageSender The object to use for sending guaranteed events.
      * @param captionManager The optional @c CaptionManagerInterface instance to use for handling captions.
      * @param metricRecorder The metric recorder.
      * @return A @c std::shared_ptr to the new @c AudioPlayer instance.
@@ -104,9 +106,11 @@ public:
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter,
         std::vector<std::shared_ptr<avsCommon::sdkInterfaces::ChannelVolumeInterface>> audioChannelVolumeInterfaces,
+        std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
         std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr,
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr);
 
+
     /// @name StateProviderInterface Functions
     /// @{
     void provideState(const avsCommon::avs::NamespaceAndName& stateProviderName, unsigned int stateRequestToken)
@@ -250,6 +254,7 @@ private:
      * @param audioChannelVolumeInterfaces A list of @c ChannelVolumeInterface instances to use to control/attenuate
      * channel volume. These instances are required for controlling volume for the @c MediaPlayerInterface instances
      * created by @param mediaPlayerFactory.
+     * @param certifiedMessageSender The object to use for sending guaranteed events.
      * @param captionManager The optional @c CaptionManagerInterface instance to use for handling captions.
      * @param metricRecorder The metric recorder.
      * @return A @c std::shared_ptr to the new @c AudioPlayer instance.
@@ -262,9 +267,11 @@ private:
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter,
         std::vector<std::shared_ptr<avsCommon::sdkInterfaces::ChannelVolumeInterface>> audioChannelVolumeInterfaces,
+        std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
         std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr,
         std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> metricRecorder = nullptr);
 
+
     /// @name RequiresShutdown Functions
     /// @{
     void doShutdown() override;
@@ -845,6 +852,10 @@ private:
      *     before the Executor Thread Variables are destroyed.
      */
     avsCommon::utils::threading::Executor m_executor;
+
+    /// The CertifiedSender object.
+    std::shared_ptr<certifiedSender::CertifiedSender> m_certifiedSender;
+
 };
 
 }  // namespace audioPlayer
diff --git a/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp b/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp
index b2ce9d15..8d238d74 100644
--- a/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp
+++ b/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp
@@ -45,6 +45,7 @@ using namespace avsCommon::utils::logger;
 using namespace avsCommon::utils::mediaPlayer;
 using namespace avsCommon::utils::metrics;
 using MediaPlayerState = avsCommon::utils::mediaPlayer::MediaPlayerState;
+using namespace certifiedSender;
 
 /// AudioPlayer capability constants
 /// AudioPlayer interface type
@@ -288,8 +289,10 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
     std::shared_ptr<PlaybackRouterInterface> playbackRouter,
     std::vector<std::shared_ptr<ChannelVolumeInterface>> audioChannelVolumeInterfaces,
+    std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
     std::shared_ptr<captions::CaptionManagerInterface> captionManager,
     std::shared_ptr<MetricRecorderInterface> metricRecorder) {
+    
     if (nullptr == mediaPlayerFactory) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullMediaPlayerFactory"));
         return nullptr;
@@ -311,8 +314,12 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
     } else if (audioChannelVolumeInterfaces.empty()) {
         ACSDK_ERROR(LX("createFailed").d("reason", "emptyAudioChannelVolumeInterfaces"));
         return nullptr;
+    } else if (nullptr == certifiedMessageSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullCertifiedMessageSender"));
+        return nullptr;
     }
 
+
     auto audioPlayer = std::shared_ptr<AudioPlayer>(new AudioPlayer(
         std::move(mediaPlayerFactory),
         messageSender,
@@ -321,6 +328,7 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
         exceptionSender,
         playbackRouter,
         audioChannelVolumeInterfaces,
+        certifiedMessageSender,
         captionManager,
         metricRecorder));
     contextManager->setStateProvider(STATE, audioPlayer);
@@ -653,6 +661,7 @@ AudioPlayer::AudioPlayer(
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
     std::shared_ptr<PlaybackRouterInterface> playbackRouter,
     std::vector<std::shared_ptr<ChannelVolumeInterface>> audioChannelVolumeInterfaces,
+    std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
     std::shared_ptr<captions::CaptionManagerInterface> captionManager,
     std::shared_ptr<MetricRecorderInterface> metricRecorder) :
         CapabilityAgent{NAMESPACE, exceptionSender},
@@ -673,7 +682,8 @@ AudioPlayer::AudioPlayer(
         m_audioChannelVolumeInterfaces{audioChannelVolumeInterfaces},
         m_currentMixability{avsCommon::avs::ContentType::UNDEFINED},
         m_mixingBehavior{avsCommon::avs::MixingBehavior::UNDEFINED},
-        m_isAutoProgressing{false} {
+        m_isAutoProgressing{false},
+        m_certifiedSender{certifiedMessageSender} {
     Fingerprint fingerprint = m_mediaPlayerFactory->getFingerprint();
     m_capabilityConfigurations.insert(getAudioPlayerCapabilityConfiguration(fingerprint));
 }
@@ -710,6 +720,7 @@ void AudioPlayer::doShutdown() {
     clearPlayQueue(true);
     m_playbackRouter.reset();
     m_captionManager.reset();
+    m_certifiedSender.reset();
 }
 
 bool AudioPlayer::parseDirectivePayload(std::shared_ptr<DirectiveInfo> info, rapidjson::Document* document) {
@@ -1639,6 +1650,7 @@ bool AudioPlayer::configureMediaPlayer(std::shared_ptr<PlayDirectiveInfo>& playb
                     "failed to set attachment media source",
                     getMediaPlayerState());
                 ACSDK_ERROR(LX("configureMediaPlayerFailed").d("reason", "setSourceFailed").d("type", "attachment"));
+                m_mediaPlayerFactory->releaseMediaPlayer(mediaPlayer);
                 return false;
             }
         } else {
@@ -1652,6 +1664,7 @@ bool AudioPlayer::configureMediaPlayer(std::shared_ptr<PlayDirectiveInfo>& playb
                     "failed to set URL media source",
                     getMediaPlayerState());
                 ACSDK_ERROR(LX("configureMediaPlayerFailed").d("reason", "setSourceFailed").d("type", "URL"));
+                m_mediaPlayerFactory->releaseMediaPlayer(mediaPlayer);
                 return false;
             }
         }
@@ -1777,7 +1790,8 @@ void AudioPlayer::executePlay(const std::string& messageId) {
     ACSDK_DEBUG1(LX(__func__));
 
     if (m_audioPlayQueue.empty()) {
-        ACSDK_ERROR(LX("executePlayFailed").d("reason", "emptyPlayQueue"));
+        ACSDK_ERROR(
+            LX("executePlayFailed").d("reason", "emptyPlayQueue").d("messageId", messageId));
         return;
     }
 
@@ -2023,6 +2037,10 @@ void AudioPlayer::sendEventWithTokenAndOffset(
     }
 
     auto event = buildJsonEventString(eventName, "", buffer.GetString());
+    if (eventName == "PlaybackNearlyFinished" || eventName == "PlaybackFinished" ) {
+        m_certifiedSender->sendJSONMessage(event.second);
+        return;
+    }
     auto request = std::make_shared<MessageRequest>(event.second);
     m_messageSender->sendMessage(request);
 }
diff --git a/CapabilityAgents/AudioPlayer/src/CMakeLists.txt b/CapabilityAgents/AudioPlayer/src/CMakeLists.txt
index 1d650e62..23362e80 100644
--- a/CapabilityAgents/AudioPlayer/src/CMakeLists.txt
+++ b/CapabilityAgents/AudioPlayer/src/CMakeLists.txt
@@ -4,10 +4,15 @@ add_library(AudioPlayer SHARED
     ProgressTimer.cpp)
 target_include_directories(AudioPlayer PUBLIC
     "${AudioPlayer_SOURCE_DIR}/include"
+    "${CertifiedSender_SOURCE_DIR}/include"
+    "${SQLiteStorage_SOURCE_DIR}/include"
     "${AVSCommon_INCLUDE_DIRS}")
 target_link_libraries(AudioPlayer
     Captions
-    AVSCommon)
+    AVSCommon
+    CertifiedSender 
+    SQLiteStorage)
+
 
 # install target
 asdk_install()
diff --git a/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp b/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp
index 98e64df0..77dbc413 100644
--- a/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp
+++ b/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp
@@ -36,12 +36,14 @@
 #include <AVSCommon/SDKInterfaces/MockMessageSender.h>
 #include <AVSCommon/SDKInterfaces/MockPlaybackRouter.h>
 #include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/SDKInterfaces/MockAVSConnectionManager.h>
 #include <AVSCommon/Utils/JSON/JSONUtils.h>
 #include <AVSCommon/Utils/MediaPlayer/MockMediaPlayer.h>
 #include <AVSCommon/Utils/MediaPlayer/PooledMediaPlayerFactory.h>
 #include <AVSCommon/Utils/Memory/Memory.h>
 #include <AVSCommon/Utils/Metrics/MockMetricRecorder.h>
 #include <MockCaptionManager.h>
+#include <MockCertifiedSender.h>
 
 #include "AudioPlayer/AudioPlayer.h"
 
@@ -65,6 +67,7 @@ using namespace captions::test;
 using namespace avsCommon::utils::mediaPlayer::test;
 using namespace rapidjson;
 using MediaPlayerState = avsCommon::utils::mediaPlayer::MediaPlayerState;
+using namespace registrationManager;
 
 /// Plenty of time for a test to complete.
 static std::chrono::milliseconds MY_WAIT_TIMEOUT(1000);
@@ -578,6 +581,11 @@ public:
 
     /// The mock @c MetricRecorderInterface
     std::shared_ptr<MockMetricRecorder> m_mockMetricRecorder;
+    
+    std::shared_ptr<MockAVSConnectionManager> m_mockAVSConnectionManager;
+
+    /// The mock @c CertifiedSender
+    std::shared_ptr<certifiedSender::test::MockCertifiedSender> m_mockCertifiedSender;
 
     /**
      * This is invoked in response to a @c setState call.
@@ -772,6 +780,9 @@ void AudioPlayerTest::SetUp() {
     m_mockFactory = alexaClientSDK::mediaPlayer::PooledMediaPlayerFactory::create(pool, FINGERPRINT);
     m_mockCaptionManager = std::make_shared<NiceMock<MockCaptionManager>>();
     m_mockMetricRecorder = std::make_shared<NiceMock<MockMetricRecorder>>();
+    m_mockCertifiedSender = std::make_shared<certifiedSender::test::MockCertifiedSender>();
+    m_mockAVSConnectionManager = std::make_shared<NiceMock<MockAVSConnectionManager>>();
+
     m_audioPlayer = AudioPlayer::create(
         std::move(m_mockFactory),
         m_mockMessageSender,
@@ -780,6 +791,7 @@ void AudioPlayerTest::SetUp() {
         m_mockExceptionSender,
         m_mockPlaybackRouter,
         {m_mockSpeaker},
+        m_mockCertifiedSender->get(),
         m_mockCaptionManager,
         m_mockMetricRecorder);
 
@@ -824,6 +836,7 @@ void AudioPlayerTest::reSetUp(int numberOfPlayers) {
         m_mockExceptionSender,
         m_mockPlaybackRouter,
         {m_mockSpeaker},
+        m_mockCertifiedSender->get(),
         m_mockCaptionManager,
         m_mockMetricRecorder);
 
@@ -1142,6 +1155,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockExceptionSender,
         m_mockPlaybackRouter,
         {m_mockSpeaker},
+        m_mockCertifiedSender->get(),
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1155,6 +1169,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockExceptionSender,
         m_mockPlaybackRouter,
         {m_mockSpeaker},
+        m_mockCertifiedSender->get(),
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1168,6 +1183,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockExceptionSender,
         m_mockPlaybackRouter,
         {m_mockSpeaker},
+        m_mockCertifiedSender->get(),
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1181,6 +1197,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockExceptionSender,
         m_mockPlaybackRouter,
         {m_mockSpeaker},
+        m_mockCertifiedSender->get(),
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1194,6 +1211,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         nullptr,
         m_mockPlaybackRouter,
         {m_mockSpeaker},
+        m_mockCertifiedSender->get(),
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1207,6 +1225,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockExceptionSender,
         nullptr,
         {m_mockSpeaker},
+        m_mockCertifiedSender->get(),
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
@@ -1220,6 +1239,21 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockExceptionSender,
         m_mockPlaybackRouter,
         {},
+        m_mockCertifiedSender->get(),
+        m_mockCaptionManager,
+        m_mockMetricRecorder);
+    EXPECT_EQ(testAudioPlayer, nullptr);
+
+    m_mockFactory = alexaClientSDK::mediaPlayer::PooledMediaPlayerFactory::create(pool);
+    testAudioPlayer = AudioPlayer::create(
+        std::move(m_mockFactory),
+        m_mockMessageSender,
+        m_mockFocusManager,
+        m_mockContextManager,
+        m_mockExceptionSender,
+        m_mockPlaybackRouter,
+        {m_mockSpeaker},
+        nullptr,
         m_mockCaptionManager,
         m_mockMetricRecorder);
     EXPECT_EQ(testAudioPlayer, nullptr);
diff --git a/CapabilityAgents/AudioPlayer/test/CMakeLists.txt b/CapabilityAgents/AudioPlayer/test/CMakeLists.txt
index a85ff308..2fe9daa2 100644
--- a/CapabilityAgents/AudioPlayer/test/CMakeLists.txt
+++ b/CapabilityAgents/AudioPlayer/test/CMakeLists.txt
@@ -3,6 +3,7 @@ cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
 set(INCLUDE_PATH
 	"${AudioPlayer_INCLUDE_DIRS}"
 	"${AVSCommon_SOURCE_DIR}/Utils/test"
-	"${CaptionsTestLib_INCLUDE_DIRS}")
+	"${CaptionsTestLib_INCLUDE_DIRS}"
+	"${CertifiedSenderCommonTestLib_INCLUDE_DIRS}")
 
-discover_unit_tests("${INCLUDE_PATH}" "AudioPlayer;CaptionsTestLib;UtilsCommonTestLib;SDKInterfacesTests")
+discover_unit_tests("${INCLUDE_PATH}" "AudioPlayer;CaptionsTestLib;CertifiedSenderCommonTestLib;UtilsCommonTestLib;SDKInterfacesTests")
diff --git a/CapabilityAgents/CMakeLists.txt b/CapabilityAgents/CMakeLists.txt
index 92b844ff..5ad8d60f 100644
--- a/CapabilityAgents/CMakeLists.txt
+++ b/CapabilityAgents/CMakeLists.txt
@@ -13,6 +13,7 @@ set(CAPABILITY_AGENTS
         "Equalizer"
         "ExternalMediaPlayer"
         "InteractionModel"
+        "Messaging"
         "MRM"
         "Notifications"
         "PlaybackController"
diff --git a/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h b/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h
index f9663bbc..9991a9d7 100644
--- a/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h
+++ b/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h
@@ -111,7 +111,7 @@ public:
 
     /// @name Overridden @c CallStateObserverInterface methods
     /// @{
-    void onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) override;
+    void onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo) override;
     /// @}
 
     /// @name Overridden CapabilityConfigurationInterface methods.
@@ -204,7 +204,7 @@ private:
     /**
      * This function handles when the CallState has been changed.
      */
-    void executeOnCallStateChange(const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState state);
+    void executeOnCallStateChange(const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState state, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo);
 
     /**
      * This function handles when a System.UserInactivityReport has been sent to
diff --git a/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp b/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp
index 8722379d..4cb67d90 100644
--- a/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp
+++ b/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp
@@ -240,9 +240,9 @@ void MRMCapabilityAgent::onSpeakerSettingsChanged(
     m_executor.submit([this, type]() { executeOnSpeakerSettingsChanged(type); });
 }
 
-void MRMCapabilityAgent::onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) {
+void MRMCapabilityAgent::onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const CallDisplayInfo& displayInfo) {
     ACSDK_DEBUG5(LX(__func__).d("callState", callState));
-    m_executor.submit([this, callState]() { executeOnCallStateChange(callState); });
+    m_executor.submit([this, callState, displayInfo]() { executeOnCallStateChange(callState, displayInfo); });
 }
 
 std::string MRMCapabilityAgent::getVersionString() const {
@@ -323,7 +323,7 @@ void MRMCapabilityAgent::executeOnUserInactivityReportSent() {
 }
 
 void MRMCapabilityAgent::executeOnCallStateChange(
-    const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) {
+    const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo) {
     ACSDK_DEBUG5(LX(__func__));
     bool isCurrentlyActive = CallStateObserverInterface::isStateActive(callState);
 
diff --git a/CapabilityAgents/Messaging/CMakeLists.txt b/CapabilityAgents/Messaging/CMakeLists.txt
new file mode 100644
index 00000000..3450990e
--- /dev/null
+++ b/CapabilityAgents/Messaging/CMakeLists.txt
@@ -0,0 +1,5 @@
+cmake_minimum_required(VERSION 3.0)
+project(Messaging LANGUAGES CXX)
+
+add_subdirectory("src")
+add_subdirectory("test")
diff --git a/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h b/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
new file mode 100644
index 00000000..56d420a9
--- /dev/null
+++ b/CapabilityAgents/Messaging/include/Messaging/MessagingCapabilityAgent.h
@@ -0,0 +1,513 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
+#define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
+
+#include <memory>
+#include <unordered_set>
+#include <unordered_map>
+
+#include <AVSCommon/AVS/CapabilityAgent.h>
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
+#include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
+#include <AVSCommon/SDKInterfaces/ExceptionEncounteredSenderInterface.h>
+#include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
+#include <AVSCommon/SDKInterfaces/Messaging/MessagingObserverInterface.h>
+#include <AVSCommon/SDKInterfaces/StateProviderInterface.h>
+#include <AVSCommon/Utils/RequiresShutdown.h>
+#include <AVSCommon/Utils/Threading/Executor.h>
+#include <AVSCommon/Utils/UUIDGeneration/UUIDGeneration.h>
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace messaging {
+
+/**
+ * This class implements the @c MessagingController capability agent.
+ *
+ * @see https://developer.amazon.com/docs/alexa-voice-service/
+ *
+ * @note For instances of this class to be cleaned up correctly, @c shutdown() must be called.
+ * @note This class makes use of a global configuration to a database file, meaning that it is best used
+ * as a singleton.
+ */
+class MessagingCapabilityAgent
+        : public avsCommon::avs::CapabilityAgent
+        , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
+        , public avsCommon::utils::RequiresShutdown
+        , public std::enable_shared_from_this<MessagingCapabilityAgent> {
+public:
+    /**
+     * Messaging endpoint reference.
+     */
+    using MessagingEndpoint = avsCommon::sdkInterfaces::messaging::MessagingObserverInterface::MessagingEndpoint;
+
+    /**
+     * An enum representing the status error codes.
+     */
+    enum class StatusErrorCode {
+        /// Generic failure occurred during request processing.
+        GENERIC_FAILURE,
+
+        /// No connection was found during request processing.
+        NO_CONNECTIVITY,
+
+        /// Messaging endpoint does not have needed permissions.
+        NO_PERMISSION
+    };
+
+    /**
+     * An enum representing the @c UploadMode.
+     */
+    enum class UploadMode {
+        /// Existing messages should be deleted and replaced with uploaded ones.
+        DELETE_ALL_AND_STORE
+    };
+
+    /**
+     * An enum representing the @c ConnectionState.
+     */
+    enum class ConnectionState {
+        /// Messaging endpoint is disconnected.
+        DISCONNECTED,
+
+        /// Messaging endpoint is connected.
+        CONNECTED
+    };
+
+    /**
+     * An enum representing the @c Permission for @sa ConversationsReport.
+     */
+    enum class PermissionState {
+        /// Permission is turned off.
+        OFF,
+
+        /// Permission is turned on.
+        ON
+    };
+
+    /*
+     *  Defines a container for the messaging endpoint state.
+     */
+    struct MessagingEndpointState {
+        /*
+         * Constructor. Initializes the configuration to default.
+         */
+        MessagingEndpointState() :
+                connection{ConnectionState::DISCONNECTED},
+                sendPermission{PermissionState::OFF},
+                readPermission{PermissionState::OFF} {};
+
+        /**
+         * Constructor for initializing with specified states.
+         * @param connectionIn The state of the connection.
+         * @param sendPermission The state of the send permission.
+         * @param readPermission The state of the read permission.
+         */
+        MessagingEndpointState(
+            ConnectionState connectionIn,
+            PermissionState sendPermissionIn,
+            PermissionState readPermissionIn) :
+                connection{connectionIn}, sendPermission{sendPermissionIn}, readPermission{readPermissionIn} {
+        }
+
+        /// Connection state
+        ConnectionState connection;
+
+        /// Send permission state.
+        PermissionState sendPermission;
+
+        /// Read permission state.
+        PermissionState readPermission;
+    };
+
+    /**
+     * Destructor.
+     */
+    virtual ~MessagingCapabilityAgent() = default;
+
+    /**
+     * Factory method to create a @c MessagingCapabilityAgent instance.
+     *
+     * @param exceptionSender Interface to report exceptions to AVS.
+     * @param contextManager Interface to provide messaging state to AVS.
+     * @param messageSender Interface to send events to AVS.
+     * @return A new instance of @c MessagingCapabilityAgent on success, @c nullptr otherwise.
+     */
+    static std::shared_ptr<MessagingCapabilityAgent> create(
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /// @name CapabilityAgent Functions
+    /// @{
+    alexaClientSDK::avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
+    void handleDirectiveImmediately(std::shared_ptr<alexaClientSDK::avsCommon::avs::AVSDirective> directive) override;
+    void preHandleDirective(
+        std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void handleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void cancelDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    /// @}
+
+    /// @name CapabilityConfigurationInterface method
+    /// @{
+    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
+    /// @}
+
+    /// @name RequiresShutdown method
+    /// @{
+    void doShutdown() override;
+    /// @}
+
+    /// @name StateProviderInterface Functions
+    /// @{
+    void provideState(
+        const avsCommon::avs::CapabilityTag& stateProviderName,
+        const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken) override;
+    /// @}
+
+    /**
+     * Adds an observer to @c MessagingCapabilityAgent so that it will get notified for all
+     * messaging related directives.
+     *
+     * @param observer The @c MessagingObserverInterface to add.
+     */
+    void addObserver(std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface> observer);
+
+    /**
+     * Removes an observer from @c MessagingCapabilityAgent so that it will no longer be
+     * notified of messaging related directives.
+     *
+     * @param observer The @c MessagingObserverInterface
+     */
+    void removeObserver(std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface> observer);
+
+    /**
+     * Sends an event to notify AVS of new messages available on the device.
+     *
+     * @note This method should be called when the device is connected.
+     * @note If this is called in response to an @c UploadConversations directive, then the token
+     * received in @c UploadConversations should be passed back. Otherwise, an empty string should be sent.
+     *
+     * @param The token received from @c uploadConversations, otherwise an empty string.
+     * @param conversations A JSON array representing the unread messages of the messaging endpoint.
+     * @code{.json}
+     * [
+     *     {
+     *         "id": "{{STRING}}",
+     *         "otherParticipants": [
+     *             {
+     *                 "address":"{{STRING}}",
+     *                 "addressType":"PhoneNumberAddress"
+     *             }
+     *         ],
+     *         "messages": [
+     *             {
+     *                 "id":"{{STRING}}",
+     *                 "payload": {
+     *                     "@type":"text",
+     *                     "text":"{{STRING}}"
+     *                 },
+     *                 "status":"unread",
+     *                 "createdTime":"{{STRING}}",
+     *                 "sender": {
+     *                     "address":"{{STRING}}",
+     *                     "addressType":"PhoneNumberAddress"
+     *                 }
+     *             }
+     *         ],
+     *         "unreadMessageCount":1
+     *     }
+     * ]
+     * @endcode
+     * @li id A unique identifier generated by the application for the conversation.
+     * @li otherParticipants Optional recipients if messages are part of a group conversation, otherwise empty JSON
+     * array.
+     * @li otherParticipants.address The phone number of the recipient.
+     * @li otherParticipants.addressType Hard coded string "PhoneNumberAddress" indicating the value of the @c address
+     * field.
+     * @li messages.id A unique identifier generated by the application for the message.
+     * @li messages.payload.@type Hard coded string "text" indicating the value of the @c text field.
+     * @li messages.text The text for the message.
+     * @li messages.createdTime (optional) The ISO 8601 timestamp of when the message was created on the device.
+     * @li messages.sender.address The phone number of the sender.
+     * @li messages.sender.addressType Hard coded string "PhoneNumberAddress" indicating the value of the @c address
+     * field.
+     * @li unreadMessageCount The total number of unread messages in this conversation..
+     */
+    void conversationsReport(
+        const std::string& token,
+        const std::string& conversations,
+        UploadMode mode = UploadMode::DELETE_ALL_AND_STORE,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message was sent successfully.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param messagingEndpoint The messaging endpoint that sent the message successfully.
+     */
+    void sendMessageSucceeded(
+        const std::string& token,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message failed to be sent.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param code The @c StatusErrorCode describing why the request failed.
+     * @param message The reason for the failure or empty string.
+     * @param messagingEndpoint The messaging endpoint that failed to send the message.
+     */
+    void sendMessageFailed(
+        const std::string& token,
+        StatusErrorCode code,
+        const std::string& message,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message status request was successful.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::updateMessagesStatus request.
+     * @param messagingEndpoint The messaging endpoint that update status successfully.
+     */
+    void updateMessagesStatusSucceeded(
+        const std::string& token,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * Sends an event to notify AVS that the message status request failed.
+     *
+     * @param token The token corresponding to the @c MessagingObserverInterface::sendMessage request.
+     * @param code The @c StatusErrorCode describing why the request failed.
+     * @param message The reason for the failure or empty string.
+     * @param messagingEndpoint The messaging endpoint that failed to update status.
+     */
+    void updateMessagesStatusFailed(
+        const std::string& token,
+        StatusErrorCode code,
+        const std::string& message,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+    /**
+     * This function updates the @c MessagingCapabilityAgent context.
+     *
+     * @param messagingEndpointState The current state of the messaging endpoint.
+     * @param messagingEndpoint The messaging endpoint whose state will be updated.
+     */
+    void updateMessagingEndpointState(
+        MessagingEndpointState messagingEndpointState,
+        MessagingEndpoint messagingEndpoint = MessagingEndpoint::DEFAULT);
+
+private:
+    /**
+     * Constructor.
+     *
+     * @param exceptionSender Interface to report exceptions to AVS.
+     * @param contextManager Interface to provide state to AVS.
+     * @param messageSender Interface to send events to AVS
+     */
+    MessagingCapabilityAgent(
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+
+    /**
+     * Initializes the object.
+     */
+    bool initialize();
+
+    /**
+     * Prepares MessagingController Interface DCF configuration and keeps it internally.
+     */
+    void generateCapabilityConfiguration();
+
+    /**
+     * Builds JSON string for the device capabilities reported.
+     */
+    std::string buildMessagingEndpointConfigurationJson();
+
+    /**
+     * Remove a directive from the map of message IDs to DirectiveInfo instances.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective whose message ID is to be removed.
+     */
+    void removeDirective(std::shared_ptr<DirectiveInfo> info);
+
+    /**
+     * Marks the directive as completed.
+     *
+     * @param info The directive currently being handled.
+     */
+    void executeSetHandlingCompleted(std::shared_ptr<DirectiveInfo> info);
+
+    /**
+     * Handles the @c SendMessage AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload.
+     * @return @c true if operation succeeds and could be reported as such to AVS, @c false if an error occurred. False
+     * implies that exception has been reported to AVS and directive is already processed.
+     */
+    bool executeSendMessageDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * Handles the @c UpdateMessagesStatus AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload.
+     * @return @c true if operation succeeds and could be reported as such to AVS, @c false if an error occurred. False
+     * implies that exception has been reported to AVS and directive is already processed.
+     */
+    bool executeUpdateMessagesStatusDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * Handles the @c UploadConversations AVS Directive.
+     *
+     * @param info The @c DirectiveInfo containing the @c AVSDirective and the @c DirectiveHandlerResultInterface.
+     * @param payload A @c rapidjson::Document holding the parsed directive payload*
+     */
+    bool executeUploadConversationsDirective(std::shared_ptr<DirectiveInfo> info, rapidjson::Document& payload);
+
+    /**
+     * This function updates the context for the @c MessagingCapabilityAgent.
+     */
+    void executeUpdateMessagingEndpointContext();
+
+    /**
+     * Gets the current state of the messaging endpoint and notifies @c ContextManager
+     *
+     * @param stateProviderName Provides the property name and used in the @c ContextManager methods.
+     * @param contextRequestToken The token to be used when providing the response to @c ContextManager
+     */
+    void executeProvideState(
+        const avsCommon::avs::CapabilityTag& stateProviderName,
+        const avsCommon::sdkInterfaces::ContextRequestToken contextRequestToken);
+
+    /// The ContextManager object.
+    std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> m_contextManager;
+
+    /// The regular MessageSender object.
+    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
+
+    /// Set of capability configurations that will get published using DCF
+    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
+
+    /// Set of observers of MessagingObserverInterface.
+    std::unordered_set<std::shared_ptr<avsCommon::sdkInterfaces::messaging::MessagingObserverInterface>> m_observers;
+
+    /// Map of messaging endpoint to state
+    std::unordered_map<std::string, MessagingEndpointState> m_messagingEndpointsState;
+
+    /// The current context for the messaging capability agent
+    std::string m_messagingContext;
+
+    /// Mutex to guard access of m_observers.
+    std::mutex m_observerMutex;
+
+    /// An executor used for serializing requests.
+    avsCommon::utils::threading::Executor m_executor;
+};
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param messagingEndpoint The @c MessagingEndpoint value.
+ * @return The string form of the enum.
+ */
+inline std::string messagingEndpointToString(MessagingCapabilityAgent::MessagingEndpoint messagingEndpoint) {
+    switch (messagingEndpoint) {
+        case MessagingCapabilityAgent::MessagingEndpoint::DEFAULT:
+            return "DEFAULT";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c StatusErrorCode.
+ * @return The string form of the enum.
+ */
+inline std::string statusErrorCodeToString(MessagingCapabilityAgent::StatusErrorCode code) {
+    switch (code) {
+        case MessagingCapabilityAgent::StatusErrorCode::GENERIC_FAILURE:
+            return "GENERIC_FAILURE";
+        case MessagingCapabilityAgent::StatusErrorCode::NO_CONNECTIVITY:
+            return "NO_CONNECTIVITY";
+        case MessagingCapabilityAgent::StatusErrorCode::NO_PERMISSION:
+            return "NO_PERMISSION";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c UploadMode.
+ * @return The string form of the enum.
+ */
+inline std::string uploadModeToString(MessagingCapabilityAgent::UploadMode mode) {
+    switch (mode) {
+        case MessagingCapabilityAgent::UploadMode::DELETE_ALL_AND_STORE:
+            return "DELETE_ALL_AND_STORE";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c ConnectionState.
+ * @return The string form of the enum.
+ */
+inline std::string connectionStateToString(MessagingCapabilityAgent::ConnectionState connection) {
+    switch (connection) {
+        case MessagingCapabilityAgent::ConnectionState::CONNECTED:
+            return "CONNECTED";
+        case MessagingCapabilityAgent::ConnectionState::DISCONNECTED:
+            return "DISCONNECTED";
+    }
+
+    return "UNKNOWN";
+}
+
+/**
+ * Converts an enum to a string.
+ *
+ * @param code The @c PermissionState.
+ * @return The string form of the enum.
+ */
+inline std::string permissionStateToString(MessagingCapabilityAgent::PermissionState permission) {
+    switch (permission) {
+        case MessagingCapabilityAgent::PermissionState::ON:
+            return "ON";
+        case MessagingCapabilityAgent::PermissionState::OFF:
+            return "OFF";
+    }
+
+    return "UNKNOWN";
+}
+
+}  // namespace messaging
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MESSAGING_INCLUDE_MESSAGING_MESSAGINGCAPABILITYAGENT_H_
\ No newline at end of file
diff --git a/CapabilityAgents/Messaging/src/CMakeLists.txt b/CapabilityAgents/Messaging/src/CMakeLists.txt
new file mode 100644
index 00000000..ad7b3555
--- /dev/null
+++ b/CapabilityAgents/Messaging/src/CMakeLists.txt
@@ -0,0 +1,13 @@
+add_definitions("-DACSDK_LOG_MODULE=messaging")
+
+add_library(Messaging SHARED
+        MessagingCapabilityAgent.cpp)
+
+target_include_directories(Messaging PUBLIC
+        "${Messaging_SOURCE_DIR}/include"
+        "${AVSCommon_INCLUDE_DIRS}")
+
+target_link_libraries(Messaging AVSCommon)
+
+# install target
+asdk_install()
diff --git a/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp b/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
new file mode 100644
index 00000000..188016ba
--- /dev/null
+++ b/CapabilityAgents/Messaging/src/MessagingCapabilityAgent.cpp
@@ -0,0 +1,697 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <rapidjson/document.h>
+#include <rapidjson/error/en.h>
+#include <rapidjson/stringbuffer.h>
+#include <rapidjson/writer.h>
+
+#include <AVSCommon/AVS/CapabilityConfiguration.h>
+#include <AVSCommon/AVS/MessageRequest.h>
+#include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/JSON/JSONUtils.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+#include "Messaging/MessagingCapabilityAgent.h"
+
+namespace alexaClientSDK {
+namespace capabilityAgents {
+namespace messaging {
+
+using namespace avsCommon::avs;
+using namespace avsCommon::sdkInterfaces;
+using namespace avsCommon::sdkInterfaces::messaging;
+using namespace avsCommon::utils::json::jsonUtils;
+using namespace avsCommon::utils::json;
+using namespace avsCommon::utils::logger;
+using namespace rapidjson;
+
+// ==== Messaging Capability Agent constants ===
+
+/// String to identify log entries originating from this file.
+static const std::string TAG{"Messaging"};
+
+/// The MessagingController interface namespace.
+static const std::string NAMESPACE{"Alexa.Comms.MessagingController"};
+
+/// MessagingController interface type.
+static const std::string MESSAGING_CAPABILITY_INTERFACE_TYPE = "AlexaInterface";
+
+/// MessagingController interface version.
+static const std::string MESSAGING_CAPABILITY_INTERFACE_VERSION = "1.0";
+
+/// The MessagingController context namespace.
+static const NamespaceAndName CONTEXT_MANAGER_MESSAGING_STATE{NAMESPACE, "MessagingControllerState"};
+
+// ==== Directives ===
+
+/// The @c SendMessage directive identifier.
+static const NamespaceAndName SEND_MESSAGE{NAMESPACE, "SendMessage"};
+
+/// The @c UpdateMessagesStatus directive identifier.
+static const NamespaceAndName UPDATE_MESSAGES_STATUS{NAMESPACE, "UpdateMessagesStatus"};
+
+/// The @c UploadConversations directive identifier.
+static const NamespaceAndName UPLOAD_CONVERSATIONS{NAMESPACE, "UploadConversations"};
+
+// ==== Events ===
+
+/// The @c SendMessageSucceeded event identifier.
+static const std::string SEND_MESSAGE_SUCCEEDED = "SendMessageSucceeded";
+
+/// The @c SendMessageFailed event identifier.
+static const std::string SEND_MESSAGE_FAILED = "SendMessageFailed";
+
+/// The @c UpdateMessagesStatusSucceeded event identifier.
+static const std::string UPDATE_MESSAGES_STATUS_SUCCEEDED = "UpdateMessagesStatusSucceeded";
+
+/// The @c UpdateMessagesStatusFailed event identifier.
+static const std::string UPDATE_MESSAGES_STATUS_FAILED = "UpdateMessagesStatusFailed";
+
+/// The @c ConversationsReport event identifier.
+static const std::string CONVERSATIONS_REPORT = "ConversationsReport";
+
+// ==== JSON constants ===
+
+/// Name for "token" JSON key.
+static constexpr char JSON_KEY_TOKEN[] = "token";
+
+/// Name for "conversationId" JSON key.
+static constexpr char JSON_KEY_CONVERSATION_ID[] = "conversationId";
+
+/// Name for "statusMap" JSON key.
+static constexpr char JSON_KEY_STATUS_MAP[] = "statusMap";
+
+/// Name for "messagingEndpoints" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINTS[] = "messagingEndpoints";
+
+/// Name for "messagingEndpointInfo" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_INFO[] = "messagingEndpointInfo";
+
+/// Name for "name" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_NAME[] = "name";
+
+/// Name for "messagingEndpointStates" JSON key.
+static constexpr char JSON_KEY_MESSAGING_ENDPOINT_STATES[] = "messagingEndpointStates";
+
+/// Name for "permissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_PERMISSIONS[] = "permissions";
+
+/// Name for "sendPermissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_SEND_PERMISSION[] = "sendPermission";
+
+/// Name for "readPermissions" JSON key.
+static constexpr char JSON_KEY_MESSAGING_READ_PERMISSION[] = "readPermission";
+
+/// Name for "connectionState" JSON key.
+static constexpr char JSON_KEY_CONNECTION_STATE[] = "connectionState";
+
+/// Name for "status" JSON value.
+static constexpr char JSON_KEY_STATUS[] = "status";
+
+/// Name for "uploadMode" JSON value.
+static constexpr char JSON_KEY_UPLOAD_MODE[] = "uploadMode";
+
+/// Name for "code" JSON key.
+static constexpr char JSON_KEY_STATUS_CODE[] = "code";
+
+/// Name for "message" JSON key.
+static constexpr char JSON_KEY_STATUS_MESSAGE[] = "message";
+
+/// Name for "conversations" JSON key.
+static constexpr char JSON_KEY_CONVERSATIONS[] = "conversations";
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+std::shared_ptr<MessagingCapabilityAgent> MessagingCapabilityAgent::create(
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<ContextManagerInterface> contextManager,
+    std::shared_ptr<MessageSenderInterface> messageSender) {
+    if (!contextManager) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullContextManager"));
+        return nullptr;
+    }
+
+    if (!exceptionSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullExceptionSender"));
+        return nullptr;
+    }
+
+    if (!messageSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullMessageSender"));
+        return nullptr;
+    }
+
+    // Create instance of capability agent
+    auto messagingCapabilityAgent = std::shared_ptr<MessagingCapabilityAgent>(
+        new MessagingCapabilityAgent(exceptionSender, contextManager, messageSender));
+
+    messagingCapabilityAgent->initialize();
+
+    return messagingCapabilityAgent;
+}
+
+MessagingCapabilityAgent::MessagingCapabilityAgent(
+    std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
+    std::shared_ptr<ContextManagerInterface> contextManager,
+    std::shared_ptr<MessageSenderInterface> messageSender) :
+        CapabilityAgent{NAMESPACE, exceptionSender},
+        avsCommon::utils::RequiresShutdown{"MessagingCapabilityAgent"},
+        m_contextManager{contextManager},
+        m_messageSender{messageSender} {
+}
+
+bool MessagingCapabilityAgent::initialize() {
+    ACSDK_INFO(LX(__func__));
+    // Initialize endpoint state values. One per defined messaging endpoint.
+    m_messagingEndpointsState.emplace(messagingEndpointToString(MessagingEndpoint::DEFAULT), MessagingEndpointState{});
+    // Generate the device capability configuration
+    generateCapabilityConfiguration();
+    // Register with the context manager
+    m_contextManager->addStateProvider(CONTEXT_MANAGER_MESSAGING_STATE, shared_from_this());
+    // Initialize the context
+    executeUpdateMessagingEndpointContext();
+
+    return true;
+}
+
+void MessagingCapabilityAgent::generateCapabilityConfiguration() {
+    std::unordered_map<std::string, std::string> configMap;
+
+    configMap.insert({CAPABILITY_INTERFACE_TYPE_KEY, MESSAGING_CAPABILITY_INTERFACE_TYPE});
+    configMap.insert({CAPABILITY_INTERFACE_NAME_KEY, NAMESPACE});
+    configMap.insert({CAPABILITY_INTERFACE_VERSION_KEY, MESSAGING_CAPABILITY_INTERFACE_VERSION});
+    configMap.insert({CAPABILITY_INTERFACE_CONFIGURATIONS_KEY, buildMessagingEndpointConfigurationJson()});
+
+    m_capabilityConfigurations.insert(std::make_shared<CapabilityConfiguration>(configMap));
+}
+
+std::string MessagingCapabilityAgent::buildMessagingEndpointConfigurationJson() {
+    avsCommon::utils::json::JsonGenerator jsonGenerator;
+    jsonGenerator.startArray(JSON_KEY_MESSAGING_ENDPOINTS);
+    jsonGenerator.startArrayElement();
+    jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+    jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(MessagingEndpoint::DEFAULT));
+    jsonGenerator.finishObject();
+    jsonGenerator.finishArrayElement();
+    jsonGenerator.finishArray();
+
+    ACSDK_DEBUG5(LX(__func__).sensitive("configuration", jsonGenerator.toString()));
+    return jsonGenerator.toString();
+}
+
+DirectiveHandlerConfiguration MessagingCapabilityAgent::getConfiguration() const {
+    DirectiveHandlerConfiguration configuration;
+    auto noneNonBlockingPolicy = BlockingPolicy(BlockingPolicy::MEDIUMS_NONE, false);
+
+    configuration[SEND_MESSAGE] = noneNonBlockingPolicy;
+    configuration[UPDATE_MESSAGES_STATUS] = noneNonBlockingPolicy;
+    configuration[UPLOAD_CONVERSATIONS] = noneNonBlockingPolicy;
+
+    return configuration;
+}
+
+void MessagingCapabilityAgent::provideState(
+    const CapabilityTag& stateProviderName,
+    const ContextRequestToken contextRequestToken) {
+    ACSDK_DEBUG5(
+        LX(__func__).d("contextRequestToken", contextRequestToken).sensitive("stateProviderName", stateProviderName));
+
+    m_executor.submit([this, stateProviderName, contextRequestToken] {
+        ACSDK_DEBUG5(LX("provideStateInExecutor"));
+        executeProvideState(stateProviderName, contextRequestToken);
+    });
+    return;
+}
+
+void MessagingCapabilityAgent::handleDirectiveImmediately(std::shared_ptr<AVSDirective> directive) {
+    ACSDK_DEBUG5(LX(__func__));
+    handleDirective(std::make_shared<DirectiveInfo>(directive, nullptr));
+}
+
+void MessagingCapabilityAgent::preHandleDirective(std::shared_ptr<DirectiveInfo> info) {
+    // No-op
+}
+
+/**
+ * Parses a directive payload JSON and returns a parsed document object.
+ *
+ * @param payload JSON string to parse.
+ * @param[out] document Pointer to a parsed document.
+ * @return True if parsing was successful, false otherwise.
+ */
+static bool parseDirectivePayload(const std::string& payload, Document* document) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (!document) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed").d("reason", "nullDocument"));
+        return false;
+    }
+
+    ParseResult result = document->Parse(payload);
+    if (!result) {
+        ACSDK_ERROR(LX("parseDirectivePayloadFailed")
+                        .d("reason", "parseFailed")
+                        .d("error", GetParseError_En(result.Code()))
+                        .d("offset", result.Offset()));
+        return false;
+    }
+
+    return true;
+}
+
+void MessagingCapabilityAgent::handleDirective(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (!info) {
+        ACSDK_ERROR(LX("handleDirectiveFailed").d("reason", "nullDirectiveInfo"));
+        return;
+    }
+
+    m_executor.submit([this, info] {
+        const std::string directiveName = info->directive->getName();
+
+        Document payload(kObjectType);
+        if (!parseDirectivePayload(info->directive->getPayload(), &payload)) {
+            sendExceptionEncounteredAndReportFailed(
+                info, "Unable to parse payload", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        if (directiveName == SEND_MESSAGE.name) {
+            if (!executeSendMessageDirective(info, payload)) {
+                return;
+            }
+        } else if (directiveName == UPDATE_MESSAGES_STATUS.name) {
+            if (!executeUpdateMessagesStatusDirective(info, payload)) {
+                return;
+            }
+        } else if (directiveName == UPLOAD_CONVERSATIONS.name) {
+            if (!executeUploadConversationsDirective(info, payload)) {
+                return;
+            }
+        } else {
+            sendExceptionEncounteredAndReportFailed(
+                info, "Unexpected Directive", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+            return;
+        }
+
+        executeSetHandlingCompleted(info);
+    });
+}
+
+void MessagingCapabilityAgent::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
+    removeDirective(info);
+}
+
+void MessagingCapabilityAgent::addObserver(std::shared_ptr<MessagingObserverInterface> observer) {
+    if (!observer) {
+        ACSDK_ERROR(LX("addObserverFailed").d("reason", "nullObserver"));
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock{m_observerMutex};
+    m_observers.insert(observer);
+}
+
+void MessagingCapabilityAgent::removeObserver(std::shared_ptr<MessagingObserverInterface> observer) {
+    if (!observer) {
+        ACSDK_ERROR(LX("removeObserverFailed").d("reason", "nullObserver"));
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock{m_observerMutex};
+    m_observers.erase(observer);
+}
+
+void MessagingCapabilityAgent::removeDirective(std::shared_ptr<DirectiveInfo> info) {
+    if (info->directive && info->result) {
+        CapabilityAgent::removeDirective(info->directive->getMessageId());
+    }
+}
+
+void MessagingCapabilityAgent::executeSetHandlingCompleted(std::shared_ptr<DirectiveInfo> info) {
+    ACSDK_DEBUG5(LX(__func__));
+    if (info && info->directive && info->result) {
+        info->result->setCompleted();
+    }
+    removeDirective(info);
+}
+
+bool MessagingCapabilityAgent::executeSendMessageDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    rapidjson::Value endpointInfo;
+    std::string token, name;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->sendMessage(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+bool MessagingCapabilityAgent::executeUpdateMessagesStatusDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    rapidjson::Value endpointInfo;
+    std::string token, name, conversationId;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate conversationId field
+    if (!findNode(payload, JSON_KEY_CONVERSATION_ID, &it) ||
+        !retrieveValue(payload, JSON_KEY_CONVERSATION_ID, &conversationId) || conversationId.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'conversationId' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate statusMap field
+    if (!findNode(payload, JSON_KEY_STATUS_MAP, &it) || !it->value.IsObject()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'statusMap' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->updateMessagesStatus(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+bool MessagingCapabilityAgent::executeUploadConversationsDirective(
+    std::shared_ptr<DirectiveInfo> info,
+    rapidjson::Document& payload) {
+    rapidjson::Value::ConstMemberIterator it, it2;
+    std::string token, name;
+
+    // Validate token field
+    if (!findNode(payload, JSON_KEY_TOKEN, &it) || !retrieveValue(payload, JSON_KEY_TOKEN, &token) || token.empty()) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'token' is not found or empty.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    // Validate messaging endpoint { "messagingEndpointInfo" : { "name" : "DEFAULT"} }
+    if (!findNode(payload, JSON_KEY_MESSAGING_ENDPOINT_INFO, &it) || !it->value.IsObject() ||
+        !findNode(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &it2) ||
+        !retrieveValue(it->value, JSON_KEY_MESSAGING_ENDPOINT_NAME, &name)) {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'messagingEndpointInfo' is not found.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    MessagingEndpoint endpoint;
+    // Validate against known endpoint values
+    if (name == "DEFAULT") {
+        endpoint = MessagingEndpoint::DEFAULT;
+    } else {
+        sendExceptionEncounteredAndReportFailed(
+            info, "'name' value is invalid.", ExceptionErrorType::UNEXPECTED_INFORMATION_RECEIVED);
+        return false;
+    }
+
+    std::unique_lock<std::mutex> lock{m_observerMutex};
+    auto observers = m_observers;
+    lock.unlock();
+
+    for (auto observer : observers) {
+        if (observer) {
+            observer->uploadConversations(token, endpoint, info->directive->getPayload());
+        }
+    }
+
+    return true;
+}
+
+std::unordered_set<std::shared_ptr<CapabilityConfiguration>> MessagingCapabilityAgent::getCapabilityConfigurations() {
+    return m_capabilityConfigurations;
+}
+
+void MessagingCapabilityAgent::doShutdown() {
+    m_executor.shutdown();
+    m_messageSender.reset();
+    // Remove state provider
+    m_contextManager->removeStateProvider(CONTEXT_MANAGER_MESSAGING_STATE);
+    m_contextManager.reset();
+}
+
+void MessagingCapabilityAgent::sendMessageSucceeded(const std::string& token, MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+
+        // Build event
+        auto event = buildJsonEventString(SEND_MESSAGE_SUCCEEDED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::sendMessageFailed(
+    const std::string& token,
+    StatusErrorCode code,
+    const std::string& message,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.startObject(JSON_KEY_STATUS);
+        jsonGenerator.addMember(JSON_KEY_STATUS_CODE, statusErrorCodeToString(code));
+        jsonGenerator.addMember(JSON_KEY_STATUS_MESSAGE, message);
+        jsonGenerator.finishObject();
+
+        // Build event
+        auto event = buildJsonEventString(SEND_MESSAGE_FAILED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagesStatusSucceeded(
+    const std::string& token,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+
+        // Build event
+        auto event = buildJsonEventString(UPDATE_MESSAGES_STATUS_SUCCEEDED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagesStatusFailed(
+    const std::string& token,
+    StatusErrorCode code,
+    const std::string& message,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.startObject(JSON_KEY_STATUS);
+        jsonGenerator.addMember(JSON_KEY_STATUS_CODE, statusErrorCodeToString(code));
+        jsonGenerator.addMember(JSON_KEY_STATUS_MESSAGE, message);
+        jsonGenerator.finishObject();
+
+        // Build event
+        auto event = buildJsonEventString(UPDATE_MESSAGES_STATUS_FAILED, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::conversationsReport(
+    const std::string& token,
+    const std::string& conversations,
+    UploadMode mode,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        avsCommon::utils::json::JsonGenerator jsonGenerator;
+
+        // Add event data
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, messagingEndpointToString(messagingEndpoint));
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_TOKEN, token);
+        jsonGenerator.addRawJsonMember(JSON_KEY_CONVERSATIONS, conversations);
+        jsonGenerator.addMember(JSON_KEY_UPLOAD_MODE, uploadModeToString(mode));
+
+        // Build event
+        auto event = buildJsonEventString(CONVERSATIONS_REPORT, "", jsonGenerator.toString());
+        auto request = std::make_shared<MessageRequest>(event.second);
+
+        // Send event
+        ACSDK_DEBUG5(LX(__func__).sensitive("event", jsonGenerator.toString()));
+        m_messageSender->sendMessage(request);
+    });
+}
+
+void MessagingCapabilityAgent::updateMessagingEndpointState(
+    MessagingEndpointState messagingEndpointState,
+    MessagingEndpoint messagingEndpoint) {
+    m_executor.submit([=]() {
+        // Update map
+        m_messagingEndpointsState[messagingEndpointToString(messagingEndpoint)] = messagingEndpointState;
+        executeUpdateMessagingEndpointContext();
+    });
+}
+
+void MessagingCapabilityAgent::executeUpdateMessagingEndpointContext() {
+    // Update context
+    avsCommon::utils::json::JsonGenerator jsonGenerator;
+    jsonGenerator.startArray(JSON_KEY_MESSAGING_ENDPOINT_STATES);
+
+    for (auto entry : m_messagingEndpointsState) {
+        jsonGenerator.startArrayElement();
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_ENDPOINT_INFO);
+        jsonGenerator.addMember(JSON_KEY_MESSAGING_ENDPOINT_NAME, entry.first);
+        jsonGenerator.finishObject();
+        jsonGenerator.addMember(JSON_KEY_CONNECTION_STATE, connectionStateToString(entry.second.connection));
+        jsonGenerator.startObject(JSON_KEY_MESSAGING_PERMISSIONS);
+        jsonGenerator.addMember(
+            JSON_KEY_MESSAGING_SEND_PERMISSION, permissionStateToString(entry.second.sendPermission));
+        jsonGenerator.addMember(
+            JSON_KEY_MESSAGING_READ_PERMISSION, permissionStateToString(entry.second.readPermission));
+        jsonGenerator.finishObject();
+        jsonGenerator.finishArrayElement();
+    }
+
+    jsonGenerator.finishArray();
+
+    // Save new context
+    m_messagingContext = jsonGenerator.toString();
+
+    ACSDK_DEBUG5(LX(__func__).sensitive("context", m_messagingContext));
+    m_contextManager->reportStateChange(
+        CONTEXT_MANAGER_MESSAGING_STATE,
+        CapabilityState{m_messagingContext},
+        AlexaStateChangeCauseType::APP_INTERACTION);
+}
+
+void MessagingCapabilityAgent::executeProvideState(
+    const CapabilityTag& stateProviderName,
+    const ContextRequestToken contextRequestToken) {
+    ACSDK_DEBUG5(LX(__func__).sensitive("context", m_messagingContext));
+    CapabilityState state{m_messagingContext};
+    m_contextManager->provideStateResponse(stateProviderName, CapabilityState{m_messagingContext}, contextRequestToken);
+}
+
+}  // namespace messaging
+}  // namespace capabilityAgents
+}  // namespace alexaClientSDK
\ No newline at end of file
diff --git a/CapabilityAgents/Messaging/test/CMakeLists.txt b/CapabilityAgents/Messaging/test/CMakeLists.txt
new file mode 100644
index 00000000..030a1271
--- /dev/null
+++ b/CapabilityAgents/Messaging/test/CMakeLists.txt
@@ -0,0 +1,8 @@
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+
+set(INCLUDE_PATH
+        "${Messaging_INCLUDE_DIRS}"
+        "${AVSCommon_SOURCE_DIR}/SDKInterfaces/test"
+        )
+
+discover_unit_tests("${INCLUDE_PATH}" "Messaging")
diff --git a/CapabilityAgents/ModeController/include/ModeController/ModeControllerAttributeBuilder.h b/CapabilityAgents/ModeController/include/ModeController/ModeControllerAttributeBuilder.h
index aa81fef0..579d8683 100644
--- a/CapabilityAgents/ModeController/include/ModeController/ModeControllerAttributeBuilder.h
+++ b/CapabilityAgents/ModeController/include/ModeController/ModeControllerAttributeBuilder.h
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@
 
 #include <unordered_map>
 
+#include <AVSCommon/AVS/CapabilitySemantics.h>
 #include <AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributeBuilderInterface.h>
 #include <AVSCommon/Utils/Optional.h>
 
@@ -52,6 +53,8 @@ public:
         const std::string& mode,
         const avsCommon::sdkInterfaces::modeController::ModeResources& modeResources) override;
     ModeControllerAttributeBuilder& setOrdered(bool ordered) override;
+    ModeControllerAttributeBuilder& withSemantics(
+        const avsCommon::avs::CapabilitySemantics& semantics) override;
     avsCommon::utils::Optional<avsCommon::sdkInterfaces::modeController::ModeControllerAttributes> build() override;
     /// @}
 
@@ -72,6 +75,9 @@ private:
 
     /// Indicates whether modes in the controller are ordered or not.
     bool m_ordered;
+
+    /// The semantics represented as an @c Optional @c CapabilitySemantics 
+    avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> m_semantics;
 };
 
 }  // namespace modeController
diff --git a/CapabilityAgents/ModeController/src/ModeControllerAttributeBuilder.cpp b/CapabilityAgents/ModeController/src/ModeControllerAttributeBuilder.cpp
index 7e743637..55bbbfc8 100644
--- a/CapabilityAgents/ModeController/src/ModeControllerAttributeBuilder.cpp
+++ b/CapabilityAgents/ModeController/src/ModeControllerAttributeBuilder.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -40,7 +40,7 @@ std::unique_ptr<ModeControllerAttributeBuilder> ModeControllerAttributeBuilder::
     return std::unique_ptr<ModeControllerAttributeBuilder>(new ModeControllerAttributeBuilder());
 }
 
-ModeControllerAttributeBuilder::ModeControllerAttributeBuilder() : m_invalidAttribute{false}, m_ordered{false} {
+ModeControllerAttributeBuilder::ModeControllerAttributeBuilder() : m_invalidAttribute{false}, m_ordered{false}, m_semantics(Optional<CapabilitySemantics>()) {
 }
 
 ModeControllerAttributeBuilder& ModeControllerAttributeBuilder::withCapabilityResources(
@@ -88,6 +88,17 @@ ModeControllerAttributeBuilder& ModeControllerAttributeBuilder::setOrdered(bool
     return *this;
 }
 
+ModeControllerAttributeBuilder& ModeControllerAttributeBuilder::withSemantics(
+        const avsCommon::avs::CapabilitySemantics& semantics) {
+    if (!semantics.isValid()) {
+        ACSDK_ERROR(LX("withSemanticsFailed").d("reason", "invalidSemantics"));
+        m_invalidAttribute = true;
+        return *this;
+    }
+    m_semantics = avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics>(semantics);
+    return *this;
+}
+
 avsCommon::utils::Optional<ModeControllerAttributes> ModeControllerAttributeBuilder::build() {
     ACSDK_DEBUG5(LX(__func__));
     auto controllerAttribute = avsCommon::utils::Optional<ModeControllerAttributes>();
@@ -103,7 +114,7 @@ avsCommon::utils::Optional<ModeControllerAttributes> ModeControllerAttributeBuil
     ACSDK_DEBUG5(LX(__func__).sensitive("capabilityResources", m_capabilityResources.toJson()));
     ACSDK_DEBUG5(LX(__func__).d("#modes", m_modes.size()));
 
-    return avsCommon::utils::Optional<ModeControllerAttributes>({m_capabilityResources, m_modes, m_ordered});
+    return Optional<ModeControllerAttributes>({m_capabilityResources, m_modes, m_ordered, m_semantics});
 }
 
 }  // namespace modeController
diff --git a/CapabilityAgents/ModeController/src/ModeControllerCapabilityAgent.cpp b/CapabilityAgents/ModeController/src/ModeControllerCapabilityAgent.cpp
index 485ae54d..4df4a3c6 100644
--- a/CapabilityAgents/ModeController/src/ModeControllerCapabilityAgent.cpp
+++ b/CapabilityAgents/ModeController/src/ModeControllerCapabilityAgent.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -70,6 +70,9 @@ static const std::string CAPABILITY_RESOURCES_KEY{"capabilityResources"};
 /// The configuration key
 static const std::string CAPABILITY_CONFIGURATION_KEY{"configuration"};
 
+/// The semantics key
+static const std::string CAPABILITY_SEMANTICS_KEY{"semantics"};
+
 /// The key in the directive payload
 static const char MODE_KEY[] = "mode";
 
@@ -372,6 +375,9 @@ avsCommon::avs::CapabilityConfiguration ModeControllerCapabilityAgent::getCapabi
     auto additionalConfigurations = CapabilityConfiguration::AdditionalConfigurations();
     additionalConfigurations[CAPABILITY_RESOURCES_KEY] = m_modeControllerAttributes.capabilityResources.toJson();
     additionalConfigurations[CAPABILITY_CONFIGURATION_KEY] = buildModeConfigurationJson();
+    if (m_modeControllerAttributes.semantics.hasValue()) {
+        additionalConfigurations[CAPABILITY_SEMANTICS_KEY] = m_modeControllerAttributes.semantics.value().toJson();
+    }
     return {CapabilityConfiguration::ALEXA_INTERFACE_TYPE,
             NAMESPACE,
             INTERFACE_VERSION,
diff --git a/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h b/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h
index 5605afa0..6493ac47 100644
--- a/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h
+++ b/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h
@@ -25,6 +25,7 @@
 #include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
 #include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/ContextRequesterInterface.h>
+#include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/PlaybackHandlerInterface.h>
 #include <AVSCommon/Utils/RequiresShutdown.h>
@@ -48,11 +49,14 @@ public:
      *
      * @param contextManager The @c ContextManagerInterface used to generate system context for events.
      * @param messageSender The @c MessageSenderInterface that sends events to AVS.
+     * @param focusManager The optional @c FocusManagerInterface that manages channel focus if the 
+     * @c PlaybackController should release the content channel on 'Pause' button press
      * @return @c nullptr if the inputs are not defined, else a new instance of @c PlaybackController.
      */
     static std::shared_ptr<PlaybackController> create(
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager = nullptr);
 
     /**
      * Destructor.
@@ -92,10 +96,13 @@ private:
      *
      * @param contextManager The AVS Context manager used to generate system context for events.
      * @param messageSender The message sender interface that sends events to AVS.
+     * @param focusManager The optional channel focus manager if the @c PlaybackController should release the content 
+     * channel on 'Pause' button press
      */
     PlaybackController(
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager = nullptr);
 
     // @name RequiresShutdown Functions
     /// @{
@@ -123,6 +130,9 @@ private:
     /// The @c ContextManager used to generate system context for events.
     std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> m_contextManager;
 
+    /// The @c FocusManager used to manage usage of the content channel.
+    std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> m_focusManager;
+
     /// The queue for storing the commands.
     std::queue<const PlaybackCommand*> m_commands;
     /// @}
diff --git a/CapabilityAgents/PlaybackController/src/PlaybackController.cpp b/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
index 592a66db..e652b37e 100644
--- a/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
+++ b/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
@@ -50,6 +50,12 @@ static const std::string TAG("PlaybackController");
 /// String to identify the AVS namespace of the event we send.
 static const std::string PLAYBACK_CONTROLLER_NAMESPACE = "PlaybackController";
 
+/// The name of the @c FocusManager channel used by @c PlaybackController.
+static const std::string CHANNEL_NAME = avsCommon::sdkInterfaces::FocusManagerInterface::CONTENT_CHANNEL_NAME;
+
+/// The name of the @c PlaybackController pause command event.
+static const std::string PAUSE_EVENT_NAME = "PauseCommandIssued";
+
 /**
  * Creates the PlaybackController capability configuration.
  *
@@ -59,7 +65,8 @@ static std::shared_ptr<CapabilityConfiguration> getPlaybackControllerCapabilityC
 
 std::shared_ptr<PlaybackController> PlaybackController::create(
     std::shared_ptr<ContextManagerInterface> contextManager,
-    std::shared_ptr<MessageSenderInterface> messageSender) {
+    std::shared_ptr<MessageSenderInterface> messageSender,
+    std::shared_ptr<FocusManagerInterface> focusManager) {
     if (!contextManager) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullContextManager"));
         return nullptr;
@@ -68,14 +75,14 @@ std::shared_ptr<PlaybackController> PlaybackController::create(
         ACSDK_ERROR(LX("createFailed").d("reason", "nullMessageSender"));
         return nullptr;
     }
-
-    return std::shared_ptr<PlaybackController>(new PlaybackController(contextManager, messageSender));
+    return std::shared_ptr<PlaybackController>(new PlaybackController(contextManager, messageSender, focusManager));
 }
 
 void PlaybackController::doShutdown() {
     m_executor.shutdown();
     m_messageSender.reset();
     m_contextManager.reset();
+    m_focusManager.reset();
 }
 
 void PlaybackController::handleCommand(const PlaybackCommand& command) {
@@ -126,10 +133,16 @@ void PlaybackController::onContextAvailable(const std::string& jsonContext) {
         auto& command = *m_commands.front();
         m_commands.pop();
 
-        auto msgIdAndJsonEvent = buildJsonEventString(
-            PLAYBACK_CONTROLLER_NAMESPACE, command.getEventName(), "", command.getEventPayload(), jsonContext);
-        m_messageSender->sendMessage(
-            std::make_shared<PlaybackMessageRequest>(command, msgIdAndJsonEvent.second, shared_from_this()));
+        if (command.getEventName() == PAUSE_EVENT_NAME && m_focusManager != nullptr) {
+            ACSDK_DEBUG9(LX("onContextAvailableExecutor").m("skippingPauseCommandIssued").m("releasingFocus"));
+            m_focusManager->releaseChannel(CHANNEL_NAME);
+        } else {
+            auto msgIdAndJsonEvent = buildJsonEventString(
+                PLAYBACK_CONTROLLER_NAMESPACE, command.getEventName(), "", command.getEventPayload(), jsonContext);
+            m_messageSender->sendMessage(
+                std::make_shared<PlaybackMessageRequest>(command, msgIdAndJsonEvent.second, shared_from_this()));
+        }
+
         if (!m_commands.empty()) {
             ACSDK_DEBUG9(LX("onContextAvailableExecutor").m("Queue is not empty, call getContext()."));
             m_contextManager->getContext(shared_from_this());
@@ -164,10 +177,12 @@ void PlaybackController::onContextFailure(const ContextRequestError error) {
 
 PlaybackController::PlaybackController(
     std::shared_ptr<ContextManagerInterface> contextManager,
-    std::shared_ptr<MessageSenderInterface> messageSender) :
+    std::shared_ptr<MessageSenderInterface> messageSender,
+    std::shared_ptr<FocusManagerInterface> focusManager) :
         RequiresShutdown{"PlaybackController"},
         m_messageSender{messageSender},
-        m_contextManager{contextManager} {
+        m_contextManager{contextManager},
+        m_focusManager{focusManager} {
     m_capabilityConfigurations.insert(getPlaybackControllerCapabilityConfiguration());
 }
 
diff --git a/CapabilityAgents/RangeController/include/RangeController/RangeControllerAttributeBuilder.h b/CapabilityAgents/RangeController/include/RangeController/RangeControllerAttributeBuilder.h
index 254813bd..e9882756 100644
--- a/CapabilityAgents/RangeController/include/RangeController/RangeControllerAttributeBuilder.h
+++ b/CapabilityAgents/RangeController/include/RangeController/RangeControllerAttributeBuilder.h
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 #ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_RANGECONTROLLER_INCLUDE_RANGECONTROLLER_RANGECONTROLLERATTRIBUTEBUILDER_H_
 #define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_RANGECONTROLLER_INCLUDE_RANGECONTROLLER_RANGECONTROLLERATTRIBUTEBUILDER_H_
 
+#include <AVSCommon/AVS/CapabilitySemantics.h>
 #include <AVSCommon/SDKInterfaces/RangeController/RangeControllerAttributeBuilderInterface.h>
 #include <AVSCommon/Utils/Optional.h>
 
@@ -50,6 +51,8 @@ public:
         const avsCommon::avs::resources::AlexaUnitOfMeasure& unitOfMeasure) override;
     RangeControllerAttributeBuilder& addPreset(
         const std::pair<double, avsCommon::sdkInterfaces::rangeController::PresetResources>& preset) override;
+    RangeControllerAttributeBuilder& withSemantics(
+        const avsCommon::avs::CapabilitySemantics& semantics) override;
     avsCommon::utils::Optional<avsCommon::sdkInterfaces::rangeController::RangeControllerAttributes> build() override;
     /// @}
 
@@ -73,6 +76,9 @@ private:
      * PresetResources.
      */
     std::vector<std::pair<double, avsCommon::sdkInterfaces::rangeController::PresetResources>> m_presets;
+
+    /// The semantics represented as an @c Optional @c CapabilitySemantics 
+    avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> m_semantics;
 };
 
 }  // namespace rangeController
diff --git a/CapabilityAgents/RangeController/src/RangeControllerAttributeBuilder.cpp b/CapabilityAgents/RangeController/src/RangeControllerAttributeBuilder.cpp
index 813a04f7..dae7491c 100644
--- a/CapabilityAgents/RangeController/src/RangeControllerAttributeBuilder.cpp
+++ b/CapabilityAgents/RangeController/src/RangeControllerAttributeBuilder.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -44,7 +44,8 @@ std::unique_ptr<RangeControllerAttributeBuilder> RangeControllerAttributeBuilder
 
 RangeControllerAttributeBuilder::RangeControllerAttributeBuilder() :
         m_invalidAttribute{false},
-        m_unitOfMeasure{Optional<resources::AlexaUnitOfMeasure>()} {
+        m_unitOfMeasure{Optional<resources::AlexaUnitOfMeasure>()},
+        m_semantics(Optional<CapabilitySemantics>()) {
 }
 
 RangeControllerAttributeBuilder& RangeControllerAttributeBuilder::withCapabilityResources(
@@ -88,6 +89,17 @@ RangeControllerAttributeBuilder& RangeControllerAttributeBuilder::addPreset(
     return *this;
 }
 
+RangeControllerAttributeBuilder& RangeControllerAttributeBuilder::withSemantics(
+        const avsCommon::avs::CapabilitySemantics& semantics) {
+    if (!semantics.isValid()) {
+        ACSDK_ERROR(LX("withSemanticsFailed").d("reason", "invalidSemantics"));
+        m_invalidAttribute = true;
+        return *this;
+    }
+    m_semantics = avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics>(semantics);
+    return *this;
+}
+
 avsCommon::utils::Optional<RangeControllerAttributes> RangeControllerAttributeBuilder::build() {
     ACSDK_DEBUG5(LX(__func__));
     avsCommon::utils::Optional<RangeControllerAttributes> controllerAttribute;
@@ -100,7 +112,7 @@ avsCommon::utils::Optional<RangeControllerAttributes> RangeControllerAttributeBu
     ACSDK_DEBUG5(LX(__func__).sensitive("unitOfMeasure", m_unitOfMeasure.valueOr("")));
     ACSDK_DEBUG5(LX(__func__).d("#presets", m_presets.size()));
 
-    return avsCommon::utils::Optional<RangeControllerAttributes>({m_capabilityResources, m_unitOfMeasure, m_presets});
+    return avsCommon::utils::Optional<RangeControllerAttributes>({m_capabilityResources, m_unitOfMeasure, m_presets, m_semantics});
 }
 
 }  // namespace rangeController
diff --git a/CapabilityAgents/RangeController/src/RangeControllerCapabilityAgent.cpp b/CapabilityAgents/RangeController/src/RangeControllerCapabilityAgent.cpp
index e2b647d7..02390ef8 100644
--- a/CapabilityAgents/RangeController/src/RangeControllerCapabilityAgent.cpp
+++ b/CapabilityAgents/RangeController/src/RangeControllerCapabilityAgent.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -23,6 +23,7 @@
 #include <rapidjson/writer.h>
 
 #include <AVSCommon/AVS/CapabilityResources.h>
+#include <AVSCommon/AVS/CapabilitySemantics.h>
 #include <AVSCommon/Utils/JSON/JSONGenerator.h>
 #include <AVSCommon/Utils/JSON/JSONUtils.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
@@ -70,6 +71,9 @@ static const std::string CAPABILITY_RESOURCES_KEY{"capabilityResources"};
 /// The configuration key
 static const std::string CAPABILITY_CONFIGURATION_KEY{"configuration"};
 
+/// The semantics key
+static const std::string CAPABILITY_SEMANTICS_KEY{"semantics"};
+
 /// The key in the directive payload
 static const char RANGE_VALUE_KEY[] = "rangeValue";
 
@@ -383,6 +387,9 @@ avsCommon::avs::CapabilityConfiguration RangeControllerCapabilityAgent::getCapab
     auto additionalConfigurations = CapabilityConfiguration::AdditionalConfigurations();
     additionalConfigurations[CAPABILITY_RESOURCES_KEY] = m_rangeControllerAttributes.capabilityResources.toJson();
     additionalConfigurations[CAPABILITY_CONFIGURATION_KEY] = buildRangeConfigurationJson();
+    if (m_rangeControllerAttributes.semantics.hasValue()) {
+        additionalConfigurations[CAPABILITY_SEMANTICS_KEY] = m_rangeControllerAttributes.semantics.value().toJson();
+    }
 
     CapabilityConfiguration configuration{CapabilityConfiguration::ALEXA_INTERFACE_TYPE,
                                           NAMESPACE,
diff --git a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
index e3fb92a0..d90ce34b 100644
--- a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
@@ -252,8 +252,12 @@ void SpeechSynthesizer::handleDirective(std::shared_ptr<DirectiveInfo> info) {
 }
 
 void SpeechSynthesizer::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
-    ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
-    m_executor.submit([this, info]() { executeCancel(info); });
+    if (info && info->directive) {
+        ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
+        m_executor.submit([this, info]() { executeCancel(info); });
+    } else {
+        ACSDK_WARN(LX("cancelDirective").d("reason", "infoNotAvailable"));
+    }
 }
 
 void SpeechSynthesizer::onFocusChanged(FocusState newFocus, MixingBehavior behavior) {
@@ -992,8 +996,12 @@ std::string SpeechSynthesizer::buildPayload(std::string& token) {
 
 void SpeechSynthesizer::startPlaying() {
     ACSDK_DEBUG9(LX("startPlaying"));
-    std::shared_ptr<AttachmentReader> attachmentReader = std::move(m_currentInfo->attachmentReader);
-    m_mediaSourceId = m_speechPlayer->setSource(std::move(attachmentReader));
+    if (m_currentInfo && m_currentInfo->attachmentReader) {
+        std::shared_ptr<AttachmentReader> attachmentReader = std::move(m_currentInfo->attachmentReader);
+        m_mediaSourceId = m_speechPlayer->setSource(std::move(attachmentReader));
+    } else {
+        m_mediaSourceId = MediaPlayerInterface::ERROR;
+    }
     if (m_captionManager && m_currentInfo->captionData.isValid()) {
         m_captionManager->onCaption(m_mediaSourceId, m_currentInfo->captionData);
     }
@@ -1060,9 +1068,14 @@ void SpeechSynthesizer::setDesiredState(SpeechSynthesizerObserverInterface::Spee
 void SpeechSynthesizer::resetCurrentInfo(std::shared_ptr<SpeakDirectiveInfo> speakInfo) {
     if (m_currentInfo != speakInfo) {
         if (m_currentInfo) {
-            removeSpeakDirectiveInfo(m_currentInfo->directive->getMessageId());
-            removeDirective(m_currentInfo->directive->getMessageId());
-            m_currentInfo->clear();
+            auto info = m_currentInfo;
+            if (info) {
+                if (info->directive) {
+                    removeSpeakDirectiveInfo(info->directive->getMessageId());
+                    removeDirective(info->directive->getMessageId());
+                }
+                info->clear();
+            }
         }
         m_currentInfo = speakInfo;
     }
diff --git a/CapabilityAgents/System/src/ReportStateHandler.cpp b/CapabilityAgents/System/src/ReportStateHandler.cpp
index fc88f0ef..cc691d29 100644
--- a/CapabilityAgents/System/src/ReportStateHandler.cpp
+++ b/CapabilityAgents/System/src/ReportStateHandler.cpp
@@ -281,7 +281,6 @@ void ReportStateHandler::sendReportState() {
 void system::ReportStateHandler::clearData() {
     std::lock_guard<std::mutex> lock(m_stateMutex);
     m_storage->clearTable(REPORT_STATE_COMPONENT_NAME, REPORT_STATE_TABLE);
-    m_storage->deleteTable(REPORT_STATE_COMPONENT_NAME, REPORT_STATE_TABLE);
 }
 
 void ReportStateHandler::addStateReportGenerator(const StateReportGenerator& generator) {
diff --git a/CapabilityAgents/System/src/SoftwareInfoSendRequest.cpp b/CapabilityAgents/System/src/SoftwareInfoSendRequest.cpp
index 6975b071..8f2d7a7f 100644
--- a/CapabilityAgents/System/src/SoftwareInfoSendRequest.cpp
+++ b/CapabilityAgents/System/src/SoftwareInfoSendRequest.cpp
@@ -101,6 +101,10 @@ void SoftwareInfoSendRequest::onSendCompleted(MessageRequestObserverInterface::S
             m_observer.reset();
         }
     } else {
+        if (!m_messageSender) {
+            ACSDK_ERROR(LX("failedToRetry").d("reason", "alreadyShutdown"));
+            return;
+        }
         // At each retry, switch the Timer used to specify the time of the next retry.
         auto& timer = m_retryTimers[m_retryCounter % (sizeof(m_retryTimers) / sizeof(m_retryTimers[0]))];
         auto delay = RETRY_TIMER.calculateTimeToRetry(m_retryCounter++);
@@ -124,7 +128,7 @@ void SoftwareInfoSendRequest::doShutdown() {
     std::lock_guard<std::mutex> lock(m_mutex);
 
     for (auto& timer : m_retryTimers) {
-        timer.stop();
+        timer.stop(false);  // should not wait to prevent deadlock
     }
 
     m_messageSender.reset();
@@ -145,6 +149,17 @@ SoftwareInfoSendRequest::SoftwareInfoSendRequest(
 void SoftwareInfoSendRequest::send() {
     ACSDK_DEBUG5(LX("send").d("firmwareVersion", m_firmwareVersion));
 
+    std::shared_ptr<MessageSenderInterface> localMessageSender;
+    {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        localMessageSender = m_messageSender;
+    }
+
+    if (!localMessageSender) {
+        ACSDK_ERROR(LX("failedToSend").d("reason", "alreadyShutdown"));
+        return;
+    }
+
     std::string jsonContent;
     if (!buildJsonForSoftwareInfo(&jsonContent, m_firmwareVersion)) {
         ACSDK_ERROR(LX("sendFailed").d("reason", "buildJsonForSoftwareInfoFailed"));
@@ -153,7 +168,7 @@ void SoftwareInfoSendRequest::send() {
     }
     auto request = std::make_shared<MessageRequest>(jsonContent);
     request->addObserver(shared_from_this());
-    m_messageSender->sendMessage(request);
+    localMessageSender->sendMessage(request);
 }
 
 bool SoftwareInfoSendRequest::buildJsonForSoftwareInfo(std::string* jsonContent, FirmwareVersion firmwareVersion) {
diff --git a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
index 866714fe..f32ef2e1 100644
--- a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
+++ b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
@@ -39,7 +39,7 @@ static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_TYPE = "AlexaInter
 /// TemplateRuntime interface name
 static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_NAME = "TemplateRuntime";
 /// TemplateRuntime interface version
-static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.1";
+static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.2";
 
 /// String to identify log entries originating from this file.
 static const std::string TAG{"TemplateRuntime"};
@@ -86,13 +86,13 @@ static const std::string AUDIO_ITEM_ID_TAG{"audioItemId"};
 static const size_t MAXIMUM_QUEUE_SIZE{100};
 
 /// Default timeout for clearing the RenderTemplate display card when SpeechSynthesizer is in FINISHED state.
-static const std::chrono::milliseconds DEFAULT_TTS_FINISHED_TIMEOUT_MS{2000};
+static const std::chrono::milliseconds DEFAULT_TTS_FINISHED_TIMEOUT_MS{8000};
 
 /// Default timeout for clearing the RenderPlayerInfo display card when AudioPlayer is in FINISHED state.
 static const std::chrono::milliseconds DEFAULT_AUDIO_FINISHED_TIMEOUT_MS{2000};
 
 /// Default timeout for clearing the RenderPlayerInfo display card when AudioPlayer is in STOPPED/PAUSED state.
-static const std::chrono::milliseconds DEFAULT_AUDIO_STOPPED_PAUSED_TIMEOUT_MS{60000};
+static const std::chrono::milliseconds DEFAULT_AUDIO_STOPPED_PAUSED_TIMEOUT_MS{1800000};
 
 /**
  * Creates the TemplateRuntime capability configuration.
diff --git a/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp b/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp
index f59b102f..96b74747 100644
--- a/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp
+++ b/CapabilityAgents/TemplateRuntime/test/TemplateRuntimeTest.cpp
@@ -50,10 +50,10 @@ using namespace ::testing;
 static std::chrono::milliseconds TIMEOUT(1000);
 
 /// Timeout when waiting for clearTemplateCard.
-static std::chrono::milliseconds TEMPLATE_TIMEOUT(5000);
+static std::chrono::milliseconds TEMPLATE_TIMEOUT(11000);
 
 /// Timeout when waiting for clearTemplateCard not called.
-static std::chrono::milliseconds TEMPLATE_NOT_CLEAR_TIMEOUT(2500);
+static std::chrono::milliseconds TEMPLATE_NOT_CLEAR_TIMEOUT(8500);
 
 /// Timeout when waiting for clearTemplateCard.
 static std::chrono::milliseconds PLAYER_FINISHED_TIMEOUT(5000);
@@ -362,7 +362,7 @@ TEST_F(TemplateRuntimeTest, test_unknownDirective) {
 
 /**
  * Tests RenderTemplate Directive. Expect that the renderTemplateCard callback will be called and clearTemplateCard will
- * be called after 2s after DialogUXState is changed to IDLE state.
+ * be called after 8s after DialogUXState is changed to IDLE state.
  */
 TEST_F(TemplateRuntimeTest, testSlow_renderTemplateDirective) {
     // Create Directive.
diff --git a/CapabilityAgents/ToggleController/include/ToggleController/ToggleControllerAttributeBuilder.h b/CapabilityAgents/ToggleController/include/ToggleController/ToggleControllerAttributeBuilder.h
index 7bf849c4..28339b95 100644
--- a/CapabilityAgents/ToggleController/include/ToggleController/ToggleControllerAttributeBuilder.h
+++ b/CapabilityAgents/ToggleController/include/ToggleController/ToggleControllerAttributeBuilder.h
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 #ifndef ALEXA_CLIENT_SDK_CAPABILITYAGENTS_TOGGLECONTROLLER_INCLUDE_TOGGLECONTROLLER_TOGGLECONTROLLERATTRIBUTEBUILDER_H_
 #define ALEXA_CLIENT_SDK_CAPABILITYAGENTS_TOGGLECONTROLLER_INCLUDE_TOGGLECONTROLLER_TOGGLECONTROLLERATTRIBUTEBUILDER_H_
 
+#include <AVSCommon/AVS/CapabilitySemantics.h>
 #include <AVSCommon/SDKInterfaces/ToggleController/ToggleControllerAttributeBuilderInterface.h>
 #include <AVSCommon/Utils/Optional.h>
 
@@ -46,6 +47,8 @@ public:
     /// @{
     ToggleControllerAttributeBuilder& withCapabilityResources(
         const avsCommon::avs::CapabilityResources& capabilityResources) override;
+    ToggleControllerAttributeBuilder& withSemantics(
+        const avsCommon::avs::CapabilitySemantics& semantics) override;
     avsCommon::utils::Optional<avsCommon::sdkInterfaces::toggleController::ToggleControllerAttributes> build() override;
     /// @}
 
@@ -60,6 +63,9 @@ private:
 
     /// The capability resources represented using @c CapabilityResources.
     avsCommon::avs::CapabilityResources m_capabilityResources;
+
+    /// The semantics represented as an @c Optional @c CapabilitySemantics 
+    avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics> m_semantics;
 };
 
 }  // namespace toggleController
diff --git a/CapabilityAgents/ToggleController/src/ToggleControllerAttributeBuilder.cpp b/CapabilityAgents/ToggleController/src/ToggleControllerAttributeBuilder.cpp
index 6220c6a9..25f9b408 100644
--- a/CapabilityAgents/ToggleController/src/ToggleControllerAttributeBuilder.cpp
+++ b/CapabilityAgents/ToggleController/src/ToggleControllerAttributeBuilder.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -40,7 +40,7 @@ std::unique_ptr<ToggleControllerAttributeBuilder> ToggleControllerAttributeBuild
     return std::unique_ptr<ToggleControllerAttributeBuilder>(new ToggleControllerAttributeBuilder());
 }
 
-ToggleControllerAttributeBuilder::ToggleControllerAttributeBuilder() : m_invalidAttribute{false} {
+ToggleControllerAttributeBuilder::ToggleControllerAttributeBuilder() : m_invalidAttribute{false}, m_semantics(Optional<CapabilitySemantics>()) {
 }
 
 ToggleControllerAttributeBuilder& ToggleControllerAttributeBuilder::withCapabilityResources(
@@ -55,6 +55,17 @@ ToggleControllerAttributeBuilder& ToggleControllerAttributeBuilder::withCapabili
     return *this;
 }
 
+ToggleControllerAttributeBuilder& ToggleControllerAttributeBuilder::withSemantics(
+        const avsCommon::avs::CapabilitySemantics& semantics) {
+    if (!semantics.isValid()) {
+        ACSDK_ERROR(LX("withSemanticsFailed").d("reason", "invalidSemantics"));
+        m_invalidAttribute = true;
+        return *this;
+    }
+    m_semantics = avsCommon::utils::Optional<avsCommon::avs::CapabilitySemantics>(semantics);
+    return *this;
+}
+
 avsCommon::utils::Optional<ToggleControllerAttributes> ToggleControllerAttributeBuilder::build() {
     ACSDK_DEBUG5(LX(__func__));
     if (m_invalidAttribute) {
@@ -63,7 +74,7 @@ avsCommon::utils::Optional<ToggleControllerAttributes> ToggleControllerAttribute
     }
 
     ACSDK_DEBUG5(LX(__func__).sensitive("capabilityResources", m_capabilityResources.toJson()));
-    return avsCommon::utils::Optional<ToggleControllerAttributes>({m_capabilityResources});
+    return avsCommon::utils::Optional<ToggleControllerAttributes>({m_capabilityResources, m_semantics});
 }
 
 }  // namespace toggleController
diff --git a/CapabilityAgents/ToggleController/src/ToggleControllerCapabilityAgent.cpp b/CapabilityAgents/ToggleController/src/ToggleControllerCapabilityAgent.cpp
index 3caaec08..94ad86ab 100644
--- a/CapabilityAgents/ToggleController/src/ToggleControllerCapabilityAgent.cpp
+++ b/CapabilityAgents/ToggleController/src/ToggleControllerCapabilityAgent.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License").
  * You may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
 
 #include "ToggleController/ToggleControllerCapabilityAgent.h"
 
+#include <AVSCommon/AVS/CapabilitySemantics.h>
 #include <AVSCommon/Utils/Logger/Logger.h>
 
 namespace alexaClientSDK {
@@ -61,14 +62,17 @@ static const std::string TOGGLESTATE_OFF{R"("OFF")"};
 /// The capabilityResources key
 static const std::string CAPABILITY_RESOURCES_KEY{"capabilityResources"};
 
+/// The semantics key
+static const std::string CAPABILITY_SEMANTICS_KEY{"semantics"};
+
 /**
  *  Helper function to validate the toggle controller attributes.
  *
- * @param toggleControllerAttributes The range controller attribute to be validated.
+ * @param toggleControllerAttributes The toggle controller attribute to be validated.
  * @result @c true if valid, otherwise @c false.
  */
 static bool isToggleControllerAttributeValid(const ToggleControllerAttributes& toggleControllerAttributes) {
-    if (!toggleControllerAttributes.isValid()) {
+    if (!toggleControllerAttributes.capabilityResources.isValid()) {
         ACSDK_ERROR(LX("isToggleControllerAttributeValidFailed").d("reason", "friendlyNamesInvalid"));
         return false;
     }
@@ -281,7 +285,10 @@ DirectiveHandlerConfiguration ToggleControllerCapabilityAgent::getConfiguration(
 avsCommon::avs::CapabilityConfiguration ToggleControllerCapabilityAgent::getCapabilityConfiguration() {
     ACSDK_DEBUG5(LX(__func__));
     auto additionalConfigurations = CapabilityConfiguration::AdditionalConfigurations();
-    additionalConfigurations[CAPABILITY_RESOURCES_KEY] = m_toggleControllerAttributes.toJson();
+    additionalConfigurations[CAPABILITY_RESOURCES_KEY] = m_toggleControllerAttributes.capabilityResources.toJson();
+    if (m_toggleControllerAttributes.semantics.hasValue()) {
+        additionalConfigurations[CAPABILITY_SEMANTICS_KEY] = m_toggleControllerAttributes.semantics.value().toJson();
+    }
     CapabilityConfiguration configuration{CapabilityConfiguration::ALEXA_INTERFACE_TYPE,
                                           NAMESPACE,
                                           INTERFACE_VERSION,
diff --git a/Captions/Implementation/src/SystemClockDelay.cpp b/Captions/Implementation/src/SystemClockDelay.cpp
index 1a9f67ba..0fb479f1 100644
--- a/Captions/Implementation/src/SystemClockDelay.cpp
+++ b/Captions/Implementation/src/SystemClockDelay.cpp
@@ -23,7 +23,7 @@ namespace captions {
 
 void SystemClockDelay::delay(std::chrono::milliseconds milliseconds) {
     auto duration =
-        std::chrono::milliseconds(std::max(std::chrono::milliseconds::zero().count(), milliseconds.count()));
+        std::chrono::milliseconds(std::max((int64_t)std::chrono::milliseconds::zero().count(), (int64_t)milliseconds.count()));
     std::this_thread::sleep_for(duration);
 }
 
diff --git a/CertifiedSender/src/CertifiedSender.cpp b/CertifiedSender/src/CertifiedSender.cpp
index d7055b66..a6f25504 100644
--- a/CertifiedSender/src/CertifiedSender.cpp
+++ b/CertifiedSender/src/CertifiedSender.cpp
@@ -184,10 +184,10 @@ inline bool shouldRetryTransmission(MessageRequestObserverInterface::Status stat
         case MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED:
         case MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT:
         case MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2:
-        case MessageRequestObserverInterface::Status::CANCELED:
-        case MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR:
         case MessageRequestObserverInterface::Status::BAD_REQUEST:
             return false;
+        case MessageRequestObserverInterface::Status::CANCELED:
+        case MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR:
         case MessageRequestObserverInterface::Status::THROTTLED:
         case MessageRequestObserverInterface::Status::PENDING:
         case MessageRequestObserverInterface::Status::NOT_CONNECTED:
@@ -290,6 +290,7 @@ std::future<bool> CertifiedSender::sendJSONMessage(
 }
 
 bool CertifiedSender::executeSendJSONMessage(std::string jsonMessage, const std::string& uriPathExtension) {
+    ACSDK_DEBUG9(LX(__func__).sensitive("jsonMessage", jsonMessage));
     std::unique_lock<std::mutex> lock(m_mutex);
 
     int queueSize = static_cast<int>(m_messagesToSend.size());
diff --git a/Endpoints/include/Endpoints/EndpointAttributeValidation.h b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
index 3ab0c34e..1242eee3 100644
--- a/Endpoints/include/Endpoints/EndpointAttributeValidation.h
+++ b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
@@ -33,6 +33,14 @@ namespace endpoints {
  */
 bool isEndpointIdValid(const avsCommon::sdkInterfaces::endpoints::EndpointIdentifier& identifier);
 
+/**
+ * Returns whether the given endpointResources follows AVS specification.
+ *
+ * @param endpointResources The endpointResources to be validated.
+ * @return @c true if valid; otherwise, return @c false.
+ */
+bool isEndpointResourcesValid(const avsCommon::avs::EndpointResources& endpointResources);
+
 /**
  * Returns whether the given name follows AVS specification.
  *
diff --git a/Endpoints/include/Endpoints/EndpointBuilder.h b/Endpoints/include/Endpoints/EndpointBuilder.h
index 7ac59614..d82e170f 100644
--- a/Endpoints/include/Endpoints/EndpointBuilder.h
+++ b/Endpoints/include/Endpoints/EndpointBuilder.h
@@ -85,6 +85,8 @@ public:
     EndpointBuilder& withFriendlyName(const std::string& friendlyName) override;
     EndpointBuilder& withDescription(const std::string& description) override;
     EndpointBuilder& withManufacturerName(const std::string& manufacturerName) override;
+    EndpointBuilder& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) override;
     EndpointBuilder& withDisplayCategory(const std::vector<std::string>& displayCategories) override;
     EndpointBuilder& withAdditionalAttributes(
         const std::string& manufacturer,
@@ -212,6 +214,9 @@ private:
     /// Flag used to indicate whether any unrecoverable error was found.
     bool m_invalidConfiguration;
 
+    /// Flag used to indicate whether endpointResources is used.
+    bool m_isEndpointResourcesUsed;
+
     /// The client endpoint id that is used to build the default endpoint and generate derived endpoints.
     const avsCommon::utils::DeviceInfo m_deviceInfo;
 
diff --git a/Endpoints/src/EndpointAttributeValidation.cpp b/Endpoints/src/EndpointAttributeValidation.cpp
index c078d38f..5ced5929 100644
--- a/Endpoints/src/EndpointAttributeValidation.cpp
+++ b/Endpoints/src/EndpointAttributeValidation.cpp
@@ -29,6 +29,10 @@ bool isEndpointIdValid(const EndpointIdentifier& identifier) {
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_ENDPOINT_IDENTIFIER_LENGTH);
 }
 
+bool isEndpointResourcesValid(const EndpointResources& endpointResources) {
+    return endpointResources.isValid();
+}
+
 bool isFriendlyNameValid(const std::string& name) {
     auto length = name.length();
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_FRIENDLY_NAME_LENGTH);
diff --git a/Endpoints/src/EndpointBuilder.cpp b/Endpoints/src/EndpointBuilder.cpp
index 249c30f4..4a67815f 100644
--- a/Endpoints/src/EndpointBuilder.cpp
+++ b/Endpoints/src/EndpointBuilder.cpp
@@ -51,8 +51,8 @@ static const std::string TAG("EndpointBuilder");
 /// String used to join attributes in the generation of the derived endpoint id.
 const std::string ENDPOINT_ID_CONCAT = "::";
 
-/// We will limit the suffix length to 10 characters for now to ensure that we don't go over the endpointId length.
-static constexpr size_t MAX_SUFFIX_LENGTH = 10;
+/// We will limit the suffix length to 64 characters for now to ensure that we don't go over the endpointId length.
+static constexpr size_t MAX_SUFFIX_LENGTH = 64;
 
 /// The display category for the AVS device endpoint;
 const std::string ALEXA_DISPLAY_CATEGORY = "ALEXA_VOICE_ENABLED";
@@ -86,6 +86,7 @@ EndpointBuilder::EndpointBuilder(
         m_isDefaultEndpoint{false},
         m_hasBeenBuilt{false},
         m_invalidConfiguration{false},
+        m_isEndpointResourcesUsed(false),
         m_deviceInfo{deviceInfo},
         m_registrationManager{endpointRegistrationManager},
         m_contextManager{contextManager},
@@ -148,6 +149,18 @@ bool EndpointBuilder::finishDefaultEndpointConfiguration() {
     return !m_invalidConfiguration;
 }
 
+EndpointBuilder& EndpointBuilder::withEndpointResources(
+        const avsCommon::avs::EndpointResources& endpointResources) {
+    m_isEndpointResourcesUsed = true;
+    if (!isEndpointResourcesValid(endpointResources)){
+        ACSDK_ERROR(LX(__func__).d("reason", "invalidEndpointResources"));
+        m_invalidConfiguration = true;
+        return *this;
+    }
+    m_attributes.endpointResources = endpointResources;
+    return *this;
+}
+
 EndpointBuilder& EndpointBuilder::withFriendlyName(const std::string& friendlyName) {
     if (!isFriendlyNameValid(friendlyName)) {
         ACSDK_ERROR(LX(__func__).d("reason", "invalidFriendlyName"));
@@ -457,7 +470,14 @@ avsCommon::utils::Optional<EndpointBuilder::EndpointIdentifier> EndpointBuilder:
         return endpointId;
     }
 
-    if (!m_isDefaultEndpoint && !isFriendlyNameValid(m_attributes.friendlyName)) {
+    if (!m_isDefaultEndpoint && m_isEndpointResourcesUsed
+                             && !isEndpointResourcesValid(m_attributes.endpointResources)) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return endpointId;
+    }
+
+    if (!m_isDefaultEndpoint && !m_isEndpointResourcesUsed
+                             && !isFriendlyNameValid(m_attributes.friendlyName)) {
         ACSDK_ERROR(
             LX("buildFailed").d("reason", "friendlyNameInvalid").sensitive("friendlyName", m_attributes.friendlyName));
         return endpointId;
@@ -479,11 +499,6 @@ avsCommon::utils::Optional<EndpointBuilder::EndpointIdentifier> EndpointBuilder:
     for (auto& capabilityBuilder : m_capabilitiesBuilders) {
         auto capability = capabilityBuilder();
         if (!capability.second) {
-            // Default endpoint might have capability configurations without a directive handler.
-            if (!m_isDefaultEndpoint) {
-                ACSDK_ERROR(LX("buildImplementationFailed").d("reason", "buildCapabilityFailed"));
-                return endpointId;
-            }
             endpoint->addCapabilityConfiguration(capability.first);
         } else {
             endpoint->addCapability(capability.first, capability.second);
diff --git a/EqualizerImplementations/src/MiscDBEqualizerStorage.cpp b/EqualizerImplementations/src/MiscDBEqualizerStorage.cpp
index 19cfa870..7daa441a 100644
--- a/EqualizerImplementations/src/MiscDBEqualizerStorage.cpp
+++ b/EqualizerImplementations/src/MiscDBEqualizerStorage.cpp
@@ -88,12 +88,6 @@ void MiscDBEqualizerStorage::clear() {
                                 .d("table", EQUALIZER_STATE_TABLE)
                                 .d("component", COMPONENT_NAME)
                                 .m("Please clear the table for proper future functioning."));
-            } else if (!m_miscStorage->deleteTable(COMPONENT_NAME, EQUALIZER_STATE_TABLE)) {
-                ACSDK_ERROR(LX("clearFailed")
-                                .d("reason", "Unable to delete the table")
-                                .d("table", EQUALIZER_STATE_TABLE)
-                                .d("component", COMPONENT_NAME)
-                                .m("Please delete the table for proper future functioning."));
             }
         }
     } else {
diff --git a/Integration/test/AudioPlayerIntegrationTest.cpp b/Integration/test/AudioPlayerIntegrationTest.cpp
index f63c1888..2d891472 100644
--- a/Integration/test/AudioPlayerIntegrationTest.cpp
+++ b/Integration/test/AudioPlayerIntegrationTest.cpp
@@ -41,6 +41,9 @@
 #include <AVSCommon/Utils/MediaPlayer/PooledMediaPlayerFactory.h>
 #include <AVSCommon/Utils/Metrics/MockMetricRecorder.h>
 #include <Captions/CaptionManagerInterface.h>
+#include <CertifiedSender/CertifiedSender.h>
+#include <CertifiedSender/SQLiteMessageStorage.h>
+
 #ifdef GSTREAMER_MEDIA_PLAYER
 #include <MediaPlayer/MediaPlayer.h>
 #else
@@ -87,6 +90,7 @@ using namespace capabilityAgents::system;
 using namespace settings;
 using namespace settings::test;
 using namespace testing;
+using namespace certifiedSender;
 #ifdef GSTREAMER_MEDIA_PLAYER
 using namespace mediaPlayer;
 #endif
@@ -396,6 +400,15 @@ protected:
         m_contentMediaPlayer = std::make_shared<TestMediaPlayer>();
 #endif
 
+        auto messageStorage =
+            SQLiteMessageStorage::create(avsCommon::utils::configuration::ConfigurationNode::getRoot());
+
+        m_certifiedSender = CertifiedSender::create(
+            m_avsConnectionManager,
+            m_avsConnectionManager->getConnectionManager(),
+            std::move(messageStorage),
+            m_customerDataManager);
+
         std::vector<std::shared_ptr<MediaPlayerInterface>> players = {m_contentMediaPlayer};
         auto mockFactory = mediaPlayer::PooledMediaPlayerFactory::create(players);
 
@@ -408,6 +421,7 @@ protected:
             m_exceptionEncounteredSender,
             m_playbackRouter,
             {m_speakerInterface},
+            m_certifiedSender,
             m_captionManager,
             m_metricRecorder);
         ASSERT_NE(nullptr, m_audioPlayer);
@@ -431,6 +445,9 @@ protected:
         if (m_audioPlayer) {
             m_audioPlayer->shutdown();
         }
+        if (m_certifiedSender) {
+            m_certifiedSender->shutdown();
+        }
         if (m_avsConnectionManager) {
             m_avsConnectionManager->shutdown();
         }
@@ -555,6 +572,7 @@ protected:
     std::unique_ptr<ACLTestContext> m_context;
 
     std::shared_ptr<TestMessageSender> m_avsConnectionManager;
+    std::shared_ptr<CertifiedSender> m_certifiedSender;
     std::shared_ptr<TestExceptionEncounteredSender> m_exceptionEncounteredSender;
     std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface> m_metricRecorder;
     std::shared_ptr<PlaybackController> m_playbackController;
@@ -579,6 +597,7 @@ protected:
     std::shared_ptr<MockSetting<WakeWordConfirmationSettingType>> m_mockWakeWordConfirmationSetting;
     std::shared_ptr<MockSetting<SpeechConfirmationSettingType>> m_mockSpeechConfirmationSetting;
     std::shared_ptr<captions::CaptionManagerInterface> m_captionManager;
+    std::shared_ptr<registrationManager::CustomerDataManager> m_customerDataManager;
 
     FocusState m_focusState;
     std::mutex m_mutex;
diff --git a/SampleApp/include/SampleApp/InteractionManager.h b/SampleApp/include/SampleApp/InteractionManager.h
index adc9c0eb..68ff70d4 100644
--- a/SampleApp/include/SampleApp/InteractionManager.h
+++ b/SampleApp/include/SampleApp/InteractionManager.h
@@ -386,7 +386,7 @@ public:
     /**
      * CallStateObserverInterface methods
      */
-    void onCallStateChange(CallState newState) override;
+    void onCallStateChange(CallState newState, const CallDisplayInfo& displayInfo) override;
 
 #ifdef ENABLE_PCC
     /**
diff --git a/SampleApp/src/InteractionManager.cpp b/SampleApp/src/InteractionManager.cpp
index 7736668a..7f30a041 100644
--- a/SampleApp/src/InteractionManager.cpp
+++ b/SampleApp/src/InteractionManager.cpp
@@ -485,7 +485,7 @@ void InteractionManager::onDialogUXStateChanged(DialogUXState state) {
     });
 }
 
-void InteractionManager::onCallStateChange(CallState state) {
+void InteractionManager::onCallStateChange(CallState state, const CallDisplayInfo& displayInfo) {
     m_executor.submit([this, state]() {
         if (CallState::CALL_CONNECTED == state) {
             if (!m_micWrapper->isStreaming()) {
diff --git a/Settings/include/Settings/Setting.h b/Settings/include/Settings/Setting.h
index f122d70d..c13a1421 100644
--- a/Settings/include/Settings/Setting.h
+++ b/Settings/include/Settings/Setting.h
@@ -187,7 +187,14 @@ template <typename ValueT>
 bool Setting<ValueT>::clearData(const ValueType& value) {
     std::lock_guard<std::mutex> lock{m_mutex};
     this->m_value = value;
-    return m_protocol->clearData();
+    // Clear customer's data before restoring the initial value
+    auto result = m_protocol->clearData();
+    if (result) {
+        // this->m_value (initial value) is restored
+        // as databaseValue.empty() == true
+        restore();
+    }
+    return result;
 }
 
 template <typename ValueT>
diff --git a/Settings/src/Types/LocaleWakeWordsSetting.cpp b/Settings/src/Types/LocaleWakeWordsSetting.cpp
index e71321c1..7129a51f 100644
--- a/Settings/src/Types/LocaleWakeWordsSetting.cpp
+++ b/Settings/src/Types/LocaleWakeWordsSetting.cpp
@@ -359,7 +359,14 @@ bool LocaleWakeWordsSetting::clearData(const DeviceLocales& locales) {
     m_pendingRequest.reset();
     m_localeStatus = SettingStatus::NOT_AVAILABLE;
     LocalesSetting::m_value = locales;
-    return m_storage->deleteSetting(LOCALE_KEY);
+    // Clear customer's data before restoring the initial value
+    auto result = m_storage->deleteSetting(LOCALE_KEY);
+    if (result) {
+        // As m_localeStatus == SettingStatus::NOT_AVAILABLE restoreInitialValue()
+        // calls LocalesSetting::get() which returns LocalesSetting::m_value
+        restoreInitialValue();
+    }
+    return result;
 }
 
 bool LocaleWakeWordsSetting::clearData(const WakeWords& wakeWords) {
@@ -368,7 +375,14 @@ bool LocaleWakeWordsSetting::clearData(const WakeWords& wakeWords) {
     m_pendingRequest.reset();
     m_wakeWordsStatus = SettingStatus::NOT_AVAILABLE;
     WakeWordsSetting::m_value = wakeWords;
-    return m_storage->deleteSetting(WAKE_WORDS_KEY);
+    // Clear customer's data before restoring the initial value
+    auto result = m_storage->deleteSetting(WAKE_WORDS_KEY);;
+    if (result) {
+        // As m_wakeWordsStatus == SettingStatus::NOT_AVAILABLE restoreInitialValue()
+        // calls WakeWordsSetting::get() which returns WakeWordsSetting::m_value
+        restoreInitialValue();
+    }
+    return result;
 }
 
 void LocaleWakeWordsSetting::restoreInitialValue() {
diff --git a/capabilities/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h b/capabilities/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h
index 80b6495a..d2fd15d3 100644
--- a/capabilities/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h
+++ b/capabilities/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h
@@ -50,11 +50,11 @@ namespace doNotDisturb {
  */
 class DoNotDisturbCapabilityAgent
         : public std::enable_shared_from_this<DoNotDisturbCapabilityAgent>
-        , public avsCommon::avs::CapabilityAgent
-        , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
-        , public avsCommon::sdkInterfaces::ConnectionStatusObserverInterface
-        , public avsCommon::utils::RequiresShutdown
-        , public settings::SettingEventSenderInterface {
+        , public alexaClientSDK::avsCommon::avs::CapabilityAgent
+        , public alexaClientSDK::avsCommon::sdkInterfaces::CapabilityConfigurationInterface
+        , public alexaClientSDK::avsCommon::sdkInterfaces::ConnectionStatusObserverInterface
+        , public alexaClientSDK::avsCommon::utils::RequiresShutdown
+        , public alexaClientSDK::settings::SettingEventSenderInterface {
 public:
     /**
      * Destructor.
@@ -70,22 +70,22 @@ public:
      * @return A new instance of @c DoNotDisturbCapabilityAgent on success, @c nullptr otherwise.
      */
     static std::shared_ptr<DoNotDisturbCapabilityAgent> create(
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
-        std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage);
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+        std::shared_ptr<alexaClientSDK::settings::storage::DeviceSettingStorageInterface> settingsStorage);
 
     /// @name CapabilityAgent Functions
     /// @{
-    avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
-    void handleDirectiveImmediately(std::shared_ptr<avsCommon::avs::AVSDirective> directive) override;
-    void preHandleDirective(std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
-    void handleDirective(std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
-    void cancelDirective(std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    alexaClientSDK::avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
+    void handleDirectiveImmediately(std::shared_ptr<alexaClientSDK::avsCommon::avs::AVSDirective> directive) override;
+    void preHandleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void handleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void cancelDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
     /// @}
 
     /// @name CapabilityConfigurationInterface Functions
     /// @{
-    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
+    std::unordered_set<std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
     /// @}
 
     // @name RequiresShutdown Functions
@@ -118,7 +118,7 @@ public:
      *
      * @return The do not disturb events metadata.
      */
-    static settings::SettingEventMetadata getDoNotDisturbEventsMetadata();
+    static alexaClientSDK::settings::SettingEventMetadata getDoNotDisturbEventsMetadata();
 
 private:
     /**
@@ -128,8 +128,8 @@ private:
      * @param messageSender Interface to send events to AVS.
      */
     DoNotDisturbCapabilityAgent(
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
 
     /**
      * Method to initialize the new instance of the capability agent.
@@ -137,7 +137,7 @@ private:
      * @param settingsStorage The storage interface that will be used to store device settings.
      * @return True on success, false otherwise.
      */
-    bool initialize(std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage);
+    bool initialize(std::shared_ptr<alexaClientSDK::settings::storage::DeviceSettingStorageInterface> settingsStorage);
 
     /**
      * Sends a DND event to the AVS.
@@ -146,7 +146,7 @@ private:
      * @param value Valid JSON string representation of the boolean value. I.e. either "true" or "false".
      * @return Future to track the completion status of the message.
      */
-    std::shared_future<avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status> sendDNDEvent(
+    std::shared_future<alexaClientSDK::avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status> sendDNDEvent(
         const std::string& eventName,
         const std::string& value);
 
@@ -164,17 +164,17 @@ private:
      * implies that exception has been reported to AVS and directive is already processed.
      */
     bool handleSetDoNotDisturbDirective(
-        std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info,
+        std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info,
         rapidjson::Document& document);
 
     /// Set of capability configurations that will get published using DCF
-    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
+    std::unordered_set<std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
 
     /// The @c MessageSenderInterface used to send event messages.
-    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
+    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
 
     /// The do not disturb mode setting.
-    std::shared_ptr<settings::Setting<bool>> m_dndModeSetting;
+    std::shared_ptr<alexaClientSDK::settings::Setting<bool>> m_dndModeSetting;
 
     /**
      * Flag indicating latest reported connection status. True if SDK is connected to the AVS and ready,
diff --git a/capabilities/DoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp b/capabilities/DoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp
index 9e897c5e..24d219b1 100644
--- a/capabilities/DoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp
+++ b/capabilities/DoNotDisturb/src/DoNotDisturbCapabilityAgent.cpp
@@ -282,14 +282,19 @@ std::shared_future<bool> DoNotDisturbCapabilityAgent::sendChangedEvent(const std
         m_hasOfflineChanges = false;
     }
 
+    // Capture-by-value dndModeSetting. (or optionally use a weak_ptr instead)
+    // this is needed to avoid a race condition where doShutdown() resets the m_dndModeSetting pointer
+    // while the lambda executes, causing a segfault if m_dndModeSetting is dereferenced.
+    auto dndModeSetting = m_dndModeSetting;
+
     // Sequentialize event processing so that no directive or another event would be handled while we sending this event
-    m_executor.submit([this, value]() {
+    m_executor.submit([this, value, dndModeSetting]() {
         MessageRequestObserverInterface::Status status = sendDNDEvent(EVENT_DONOTDISTURBCHANGED.name, value).get();
         bool isSucceeded = MessageRequestObserverInterface::Status::SUCCESS == status ||
                            MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT == status;
 
         if (!isSucceeded) {
-            sendDNDEvent(EVENT_REPORTDONOTDISTURB.name, m_dndModeSetting->get() ? "true" : "false");
+            sendDNDEvent(EVENT_REPORTDONOTDISTURB.name, dndModeSetting->get() ? "true" : "false");
         }
     });
     promise.set_value(true);
-- 
2.25.0

